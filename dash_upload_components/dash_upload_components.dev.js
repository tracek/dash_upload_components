window["dash_upload_components"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/lib/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX3VwbG9hZF9jb21wb25lbnRzLy4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanM/MzIwYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/object-assign/index.js\n");

/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar printWarning = function() {};\n\nif (true) {\n  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\n  var loggedTypeFailures = {};\n  var has = Function.call.bind(Object.prototype.hasOwnProperty);\n\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n}\n\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  if (true) {\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error;\n        // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            var err = Error(\n              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +\n              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'\n            );\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n        } catch (ex) {\n          error = ex;\n        }\n        if (error && !(error instanceof Error)) {\n          printWarning(\n            (componentName || 'React class') + ': type specification of ' +\n            location + ' `' + typeSpecName + '` is invalid; the type checker ' +\n            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +\n            'You may have forgotten to pass an argument to the type checker ' +\n            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +\n            'shape all require an argument).'\n          );\n        }\n        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error.message] = true;\n\n          var stack = getStack ? getStack() : '';\n\n          printWarning(\n            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')\n          );\n        }\n      }\n    }\n  }\n}\n\n/**\n * Resets warning cache when testing.\n *\n * @private\n */\ncheckPropTypes.resetWarningCache = function() {\n  if (true) {\n    loggedTypeFailures = {};\n  }\n}\n\nmodule.exports = checkPropTypes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX3VwbG9hZF9jb21wb25lbnRzLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanM/YTE1YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUEsSUFBSSxJQUFxQztBQUN6Qyw2QkFBNkIsbUJBQU8sQ0FBQyx5RkFBNEI7QUFDakU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0R0FBNEc7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFxuICAgICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgICAgICAgICAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgJiYgIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICcgK1xuICAgICAgICAgICAgbG9jYXRpb24gKyAnIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAnICsgdHlwZW9mIGVycm9yICsgJy4gJyArXG4gICAgICAgICAgICAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICtcbiAgICAgICAgICAgICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdGYWlsZWQgJyArIGxvY2F0aW9uICsgJyB0eXBlOiAnICsgZXJyb3IubWVzc2FnZSArIChzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVzZXRzIHdhcm5pbmcgY2FjaGUgd2hlbiB0ZXN0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gZnVuY3Rpb24oKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/prop-types/checkPropTypes.js\n");

/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactIs = __webpack_require__(/*! react-is */ \"./node_modules/react-is/index.js\");\nvar assign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\n\nvar ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\nvar checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ \"./node_modules/prop-types/checkPropTypes.js\");\n\nvar has = Function.call.bind(Object.prototype.hasOwnProperty);\nvar printWarning = function() {};\n\nif (true) {\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n}\n\nfunction emptyFunctionThatReturnsNull() {\n  return null;\n}\n\nmodule.exports = function(isValidElement, throwOnDirectAccess) {\n  /* global Symbol */\n  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n\n  /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */\n  function getIteratorFn(maybeIterable) {\n    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */\n\n  var ANONYMOUS = '<<anonymous>>';\n\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n  var ReactPropTypes = {\n    array: createPrimitiveTypeChecker('array'),\n    bool: createPrimitiveTypeChecker('boolean'),\n    func: createPrimitiveTypeChecker('function'),\n    number: createPrimitiveTypeChecker('number'),\n    object: createPrimitiveTypeChecker('object'),\n    string: createPrimitiveTypeChecker('string'),\n    symbol: createPrimitiveTypeChecker('symbol'),\n\n    any: createAnyTypeChecker(),\n    arrayOf: createArrayOfTypeChecker,\n    element: createElementTypeChecker(),\n    elementType: createElementTypeTypeChecker(),\n    instanceOf: createInstanceTypeChecker,\n    node: createNodeChecker(),\n    objectOf: createObjectOfTypeChecker,\n    oneOf: createEnumTypeChecker,\n    oneOfType: createUnionTypeChecker,\n    shape: createShapeTypeChecker,\n    exact: createStrictShapeTypeChecker,\n  };\n\n  /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */\n  /*eslint-disable no-self-compare*/\n  function is(x, y) {\n    // SameValue algorithm\n    if (x === y) {\n      // Steps 1-5, 7-10\n      // Steps 6.b-6.e: +0 != -0\n      return x !== 0 || 1 / x === 1 / y;\n    } else {\n      // Step 6.a: NaN == NaN\n      return x !== x && y !== y;\n    }\n  }\n  /*eslint-enable no-self-compare*/\n\n  /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */\n  function PropTypeError(message) {\n    this.message = message;\n    this.stack = '';\n  }\n  // Make `instanceof Error` still work for returned errors.\n  PropTypeError.prototype = Error.prototype;\n\n  function createChainableTypeChecker(validate) {\n    if (true) {\n      var manualPropTypeCallCache = {};\n      var manualPropTypeWarningCount = 0;\n    }\n    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n      componentName = componentName || ANONYMOUS;\n      propFullName = propFullName || propName;\n\n      if (secret !== ReactPropTypesSecret) {\n        if (throwOnDirectAccess) {\n          // New behavior only for users of `prop-types` package\n          var err = new Error(\n            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n            'Use `PropTypes.checkPropTypes()` to call them. ' +\n            'Read more at http://fb.me/use-check-prop-types'\n          );\n          err.name = 'Invariant Violation';\n          throw err;\n        } else if ( true && typeof console !== 'undefined') {\n          // Old behavior for people using React.PropTypes\n          var cacheKey = componentName + ':' + propName;\n          if (\n            !manualPropTypeCallCache[cacheKey] &&\n            // Avoid spamming the console because they are often not actionable except for lib authors\n            manualPropTypeWarningCount < 3\n          ) {\n            printWarning(\n              'You are manually calling a React.PropTypes validation ' +\n              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +\n              'and will throw in the standalone `prop-types` package. ' +\n              'You may be seeing this warning due to a third-party PropTypes ' +\n              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'\n            );\n            manualPropTypeCallCache[cacheKey] = true;\n            manualPropTypeWarningCount++;\n          }\n        }\n      }\n      if (props[propName] == null) {\n        if (isRequired) {\n          if (props[propName] === null) {\n            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));\n          }\n          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));\n        }\n        return null;\n      } else {\n        return validate(props, propName, componentName, location, propFullName);\n      }\n    }\n\n    var chainedCheckType = checkType.bind(null, false);\n    chainedCheckType.isRequired = checkType.bind(null, true);\n\n    return chainedCheckType;\n  }\n\n  function createPrimitiveTypeChecker(expectedType) {\n    function validate(props, propName, componentName, location, propFullName, secret) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== expectedType) {\n        // `propValue` being instance of, say, date/regexp, pass the 'object'\n        // check, but we can offer a more precise error message here rather than\n        // 'of type `object`'.\n        var preciseType = getPreciseType(propValue);\n\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createAnyTypeChecker() {\n    return createChainableTypeChecker(emptyFunctionThatReturnsNull);\n  }\n\n  function createArrayOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');\n      }\n      var propValue = props[propName];\n      if (!Array.isArray(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\n      }\n      for (var i = 0; i < propValue.length; i++) {\n        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);\n        if (error instanceof Error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!isValidElement(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!ReactIs.isValidElementType(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createInstanceTypeChecker(expectedClass) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!(props[propName] instanceof expectedClass)) {\n        var expectedClassName = expectedClass.name || ANONYMOUS;\n        var actualClassName = getClassName(props[propName]);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createEnumTypeChecker(expectedValues) {\n    if (!Array.isArray(expectedValues)) {\n      if (true) {\n        if (arguments.length > 1) {\n          printWarning(\n            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +\n            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'\n          );\n        } else {\n          printWarning('Invalid argument supplied to oneOf, expected an array.');\n        }\n      }\n      return emptyFunctionThatReturnsNull;\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      for (var i = 0; i < expectedValues.length; i++) {\n        if (is(propValue, expectedValues[i])) {\n          return null;\n        }\n      }\n\n      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {\n        var type = getPreciseType(value);\n        if (type === 'symbol') {\n          return String(value);\n        }\n        return value;\n      });\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createObjectOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');\n      }\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));\n      }\n      for (var key in propValue) {\n        if (has(propValue, key)) {\n          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n          if (error instanceof Error) {\n            return error;\n          }\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createUnionTypeChecker(arrayOfTypeCheckers) {\n    if (!Array.isArray(arrayOfTypeCheckers)) {\n       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : undefined;\n      return emptyFunctionThatReturnsNull;\n    }\n\n    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n      var checker = arrayOfTypeCheckers[i];\n      if (typeof checker !== 'function') {\n        printWarning(\n          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +\n          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'\n        );\n        return emptyFunctionThatReturnsNull;\n      }\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n        var checker = arrayOfTypeCheckers[i];\n        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {\n          return null;\n        }\n      }\n\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createNodeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!isNode(props[propName])) {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      for (var key in shapeTypes) {\n        var checker = shapeTypes[key];\n        if (!checker) {\n          continue;\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createStrictShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      // We need to check all keys in case some are required but missing from\n      // props.\n      var allKeys = assign({}, props[propName], shapeTypes);\n      for (var key in allKeys) {\n        var checker = shapeTypes[key];\n        if (!checker) {\n          return new PropTypeError(\n            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +\n            '\\nBad object: ' + JSON.stringify(props[propName], null, '  ') +\n            '\\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')\n          );\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function isNode(propValue) {\n    switch (typeof propValue) {\n      case 'number':\n      case 'string':\n      case 'undefined':\n        return true;\n      case 'boolean':\n        return !propValue;\n      case 'object':\n        if (Array.isArray(propValue)) {\n          return propValue.every(isNode);\n        }\n        if (propValue === null || isValidElement(propValue)) {\n          return true;\n        }\n\n        var iteratorFn = getIteratorFn(propValue);\n        if (iteratorFn) {\n          var iterator = iteratorFn.call(propValue);\n          var step;\n          if (iteratorFn !== propValue.entries) {\n            while (!(step = iterator.next()).done) {\n              if (!isNode(step.value)) {\n                return false;\n              }\n            }\n          } else {\n            // Iterator will provide entry [k,v] tuples rather than values.\n            while (!(step = iterator.next()).done) {\n              var entry = step.value;\n              if (entry) {\n                if (!isNode(entry[1])) {\n                  return false;\n                }\n              }\n            }\n          }\n        } else {\n          return false;\n        }\n\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  function isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === 'symbol') {\n      return true;\n    }\n\n    // falsy value can't be a Symbol\n    if (!propValue) {\n      return false;\n    }\n\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue['@@toStringTag'] === 'Symbol') {\n      return true;\n    }\n\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === 'function' && propValue instanceof Symbol) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // Equivalent of `typeof` but with special handling for array and regexp.\n  function getPropType(propValue) {\n    var propType = typeof propValue;\n    if (Array.isArray(propValue)) {\n      return 'array';\n    }\n    if (propValue instanceof RegExp) {\n      // Old webkits (at least until Android 4.0) return 'function' rather than\n      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n      // passes PropTypes.object.\n      return 'object';\n    }\n    if (isSymbol(propType, propValue)) {\n      return 'symbol';\n    }\n    return propType;\n  }\n\n  // This handles more types than `getPropType`. Only used for error messages.\n  // See `createPrimitiveTypeChecker`.\n  function getPreciseType(propValue) {\n    if (typeof propValue === 'undefined' || propValue === null) {\n      return '' + propValue;\n    }\n    var propType = getPropType(propValue);\n    if (propType === 'object') {\n      if (propValue instanceof Date) {\n        return 'date';\n      } else if (propValue instanceof RegExp) {\n        return 'regexp';\n      }\n    }\n    return propType;\n  }\n\n  // Returns a string that is postfixed to a warning about an invalid type.\n  // For example, \"undefined\" or \"of type array\"\n  function getPostfixForTypeWarning(value) {\n    var type = getPreciseType(value);\n    switch (type) {\n      case 'array':\n      case 'object':\n        return 'an ' + type;\n      case 'boolean':\n      case 'date':\n      case 'regexp':\n        return 'a ' + type;\n      default:\n        return type;\n    }\n  }\n\n  // Returns class name of the object, if any.\n  function getClassName(propValue) {\n    if (!propValue.constructor || !propValue.constructor.name) {\n      return ANONYMOUS;\n    }\n    return propValue.constructor.name;\n  }\n\n  ReactPropTypes.checkPropTypes = checkPropTypes;\n  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX3VwbG9hZF9jb21wb25lbnRzLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanM/YjA3MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLGtEQUFVO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyw0REFBZTs7QUFFcEMsMkJBQTJCLG1CQUFPLENBQUMseUZBQTRCO0FBQy9ELHFCQUFxQixtQkFBTyxDQUFDLHFFQUFrQjs7QUFFL0M7QUFDQTs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDZCQUE2QjtBQUM3QixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsS0FBSztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDRCQUE0QjtBQUM1QixPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsVUFBVSxLQUFxQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLElBQXFDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sS0FBcUMsNEZBQTRGLFNBQU07QUFDN0k7QUFDQTs7QUFFQSxtQkFBbUIsZ0NBQWdDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixnQ0FBZ0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCcuL2NoZWNrUHJvcFR5cGVzJyk7XG5cbnZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICAgKlxuICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAgICpcbiAgICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAgICogICAgICAgLi4uXG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gICAqXG4gICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAgICpcbiAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gICAqICAgICB9LFxuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICAgKlxuICAgKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gICAqXG4gICAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICAgKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gICAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgKiAgICAgICAgICApO1xuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gICAqICB9KTtcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICAgIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gICAgZWxlbWVudFR5cGU6IGNyZWF0ZUVsZW1lbnRUeXBlVHlwZUNoZWNrZXIoKSxcbiAgICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuICAgIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gICAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG4gICAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gICAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIsXG4gICAgZXhhY3Q6IGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIsXG4gIH07XG5cbiAgLyoqXG4gICAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gICAqL1xuICAvKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSovXG4gIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gICAgfVxuICB9XG4gIC8qZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuXG4gIC8qKlxuICAgKiBXZSB1c2UgYW4gRXJyb3ItbGlrZSBvYmplY3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYXMgcGVvcGxlIG1heSBjYWxsXG4gICAqIFByb3BUeXBlcyBkaXJlY3RseSBhbmQgaW5zcGVjdCB0aGVpciBvdXRwdXQuIEhvd2V2ZXIsIHdlIGRvbid0IHVzZSByZWFsXG4gICAqIEVycm9ycyBhbnltb3JlLiBXZSBkb24ndCBpbnNwZWN0IHRoZWlyIHN0YWNrIGFueXdheSwgYW5kIGNyZWF0aW5nIHRoZW1cbiAgICogaXMgcHJvaGliaXRpdmVseSBleHBlbnNpdmUgaWYgdGhleSBhcmUgY3JlYXRlZCB0b28gb2Z0ZW4sIHN1Y2ggYXMgd2hhdFxuICAgKiBoYXBwZW5zIGluIG9uZU9mVHlwZSgpIGZvciBhbnkgdHlwZSBiZWZvcmUgdGhlIG9uZSB0aGF0IG1hdGNoZWQuXG4gICAqL1xuICBmdW5jdGlvbiBQcm9wVHlwZUVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuc3RhY2sgPSAnJztcbiAgfVxuICAvLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG4gIFByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50ID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBPbGQgYmVoYXZpb3IgZm9yIHBlb3BsZSB1c2luZyBSZWFjdC5Qcm9wVHlwZXNcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSAmJlxuICAgICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA8IDNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJyArIHByb3BGdWxsTmFtZSArICdgIHByb3Agb24gYCcgKyBjb21wb25lbnROYW1lICArICdgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXG4gICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghUmVhY3RJcy5pc1ZhbGlkRWxlbWVudFR5cGUocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQgdHlwZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50cyBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXksIGdvdCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgYXJndW1lbnRzLiAnICtcbiAgICAgICAgICAgICdBIGNvbW1vbiBtaXN0YWtlIGlzIHRvIHdyaXRlIG9uZU9mKHgsIHksIHopIGluc3RlYWQgb2Ygb25lT2YoW3gsIHksIHpdKS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcywgZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgU3RyaW5nKHByb3BWYWx1ZSkgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKGhhcyhwcm9wVmFsdWUsIGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICcgKyBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlcikgKyAnIGF0IGluZGV4ICcgKyBpICsgJy4nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCkgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgYWxsIGtleXMgaW4gY2FzZSBzb21lIGFyZSByZXF1aXJlZCBidXQgbWlzc2luZyBmcm9tXG4gICAgICAvLyBwcm9wcy5cbiAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArICBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzaGFwZVR5cGVzKSwgbnVsbCwgJyAgJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBmYWxzeSB2YWx1ZSBjYW4ndCBiZSBhIFN5bWJvbFxuICAgIGlmICghcHJvcFZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG4gIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gIC8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJycgKyBwcm9wVmFsdWU7XG4gICAgfVxuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHBvc3RmaXhlZCB0byBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCB0eXBlLlxuICAvLyBGb3IgZXhhbXBsZSwgXCJ1bmRlZmluZWRcIiBvciBcIm9mIHR5cGUgYXJyYXlcIlxuICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAncmVnZXhwJzpcbiAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcbiAgUmVhY3RQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBjaGVja1Byb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZTtcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/prop-types/factoryWithTypeCheckers.js\n");

/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (true) {\n  var ReactIs = __webpack_require__(/*! react-is */ \"./node_modules/react-is/index.js\");\n\n  // By explicitly using `prop-types` you are opting into new development behavior.\n  // http://fb.me/prop-types-in-prod\n  var throwOnDirectAccess = true;\n  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ \"./node_modules/prop-types/factoryWithTypeCheckers.js\")(ReactIs.isElement, throwOnDirectAccess);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX3VwbG9hZF9jb21wb25lbnRzLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanM/ZDdiYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxJQUFxQztBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyxrREFBVTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsdUZBQTJCO0FBQ3RELENBQUMsTUFBTSxFQUlOIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKFJlYWN0SXMuaXNFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/prop-types/index.js\n");

/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX3VwbG9hZF9jb21wb25lbnRzLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzPzU5YjAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/prop-types/lib/ReactPropTypesSecret.js\n");

/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/** @license React v16.8.6\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol.for;\n\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;\nvar REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;\nvar REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;\nvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;\nvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace;\nvar REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;\nvar REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;\nvar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\nvar REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;\nvar REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;\nvar REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;\n\nfunction isValidElementType(type) {\n  return typeof type === 'string' || typeof type === 'function' ||\n  // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE);\n}\n\n/**\n * Forked from fbjs/warning:\n * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\n *\n * Only change is we use console.warn instead of console.error,\n * and do nothing when 'console' is not supported.\n * This really simplifies the code.\n * ---\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar lowPriorityWarning = function () {};\n\n{\n  var printWarning = function (format) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message = 'Warning: ' + format.replace(/%s/g, function () {\n      return args[argIndex++];\n    });\n    if (typeof console !== 'undefined') {\n      console.warn(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  lowPriorityWarning = function (condition, format) {\n    if (format === undefined) {\n      throw new Error('`lowPriorityWarning(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n    if (!condition) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nvar lowPriorityWarning$1 = lowPriorityWarning;\n\nfunction typeOf(object) {\n  if (typeof object === 'object' && object !== null) {\n    var $$typeof = object.$$typeof;\n    switch ($$typeof) {\n      case REACT_ELEMENT_TYPE:\n        var type = object.type;\n\n        switch (type) {\n          case REACT_ASYNC_MODE_TYPE:\n          case REACT_CONCURRENT_MODE_TYPE:\n          case REACT_FRAGMENT_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_SUSPENSE_TYPE:\n            return type;\n          default:\n            var $$typeofType = type && type.$$typeof;\n\n            switch ($$typeofType) {\n              case REACT_CONTEXT_TYPE:\n              case REACT_FORWARD_REF_TYPE:\n              case REACT_PROVIDER_TYPE:\n                return $$typeofType;\n              default:\n                return $$typeof;\n            }\n        }\n      case REACT_LAZY_TYPE:\n      case REACT_MEMO_TYPE:\n      case REACT_PORTAL_TYPE:\n        return $$typeof;\n    }\n  }\n\n  return undefined;\n}\n\n// AsyncMode is deprecated along with isAsyncMode\nvar AsyncMode = REACT_ASYNC_MODE_TYPE;\nvar ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;\nvar ContextConsumer = REACT_CONTEXT_TYPE;\nvar ContextProvider = REACT_PROVIDER_TYPE;\nvar Element = REACT_ELEMENT_TYPE;\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Fragment = REACT_FRAGMENT_TYPE;\nvar Lazy = REACT_LAZY_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nvar Portal = REACT_PORTAL_TYPE;\nvar Profiler = REACT_PROFILER_TYPE;\nvar StrictMode = REACT_STRICT_MODE_TYPE;\nvar Suspense = REACT_SUSPENSE_TYPE;\n\nvar hasWarnedAboutDeprecatedIsAsyncMode = false;\n\n// AsyncMode should be deprecated\nfunction isAsyncMode(object) {\n  {\n    if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n      hasWarnedAboutDeprecatedIsAsyncMode = true;\n      lowPriorityWarning$1(false, 'The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');\n    }\n  }\n  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;\n}\nfunction isConcurrentMode(object) {\n  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;\n}\nfunction isContextConsumer(object) {\n  return typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isContextProvider(object) {\n  return typeOf(object) === REACT_PROVIDER_TYPE;\n}\nfunction isElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nfunction isForwardRef(object) {\n  return typeOf(object) === REACT_FORWARD_REF_TYPE;\n}\nfunction isFragment(object) {\n  return typeOf(object) === REACT_FRAGMENT_TYPE;\n}\nfunction isLazy(object) {\n  return typeOf(object) === REACT_LAZY_TYPE;\n}\nfunction isMemo(object) {\n  return typeOf(object) === REACT_MEMO_TYPE;\n}\nfunction isPortal(object) {\n  return typeOf(object) === REACT_PORTAL_TYPE;\n}\nfunction isProfiler(object) {\n  return typeOf(object) === REACT_PROFILER_TYPE;\n}\nfunction isStrictMode(object) {\n  return typeOf(object) === REACT_STRICT_MODE_TYPE;\n}\nfunction isSuspense(object) {\n  return typeOf(object) === REACT_SUSPENSE_TYPE;\n}\n\nexports.typeOf = typeOf;\nexports.AsyncMode = AsyncMode;\nexports.ConcurrentMode = ConcurrentMode;\nexports.ContextConsumer = ContextConsumer;\nexports.ContextProvider = ContextProvider;\nexports.Element = Element;\nexports.ForwardRef = ForwardRef;\nexports.Fragment = Fragment;\nexports.Lazy = Lazy;\nexports.Memo = Memo;\nexports.Portal = Portal;\nexports.Profiler = Profiler;\nexports.StrictMode = StrictMode;\nexports.Suspense = Suspense;\nexports.isValidElementType = isValidElementType;\nexports.isAsyncMode = isAsyncMode;\nexports.isConcurrentMode = isConcurrentMode;\nexports.isContextConsumer = isContextConsumer;\nexports.isContextProvider = isContextProvider;\nexports.isElement = isElement;\nexports.isForwardRef = isForwardRef;\nexports.isFragment = isFragment;\nexports.isLazy = isLazy;\nexports.isMemo = isMemo;\nexports.isPortal = isPortal;\nexports.isProfiler = isProfiler;\nexports.isStrictMode = isStrictMode;\nexports.isSuspense = isSuspense;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX3VwbG9hZF9jb21wb25lbnRzLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcz9hOGY1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7Ozs7QUFJYixJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7O0FBRTVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzRkFBc0YsYUFBYTtBQUNuRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsZUFBZTtBQUMzRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuOC42XG4gKiByZWFjdC1pcy5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcblxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpIDogMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpIDogMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpIDogMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKSA6IDB4ZWFjZTtcbnZhciBSRUFDVF9BU1lOQ19NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5hc3luY19tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb25jdXJyZW50X21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKSA6IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKSA6IDB4ZWFkMTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJykgOiAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubGF6eScpIDogMHhlYWQ0O1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nIHx8XG4gIC8vIE5vdGU6IGl0cyB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyBpZiBpdCdzIGEgcG9seWZpbGwuXG4gIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSk7XG59XG5cbi8qKlxuICogRm9ya2VkIGZyb20gZmJqcy93YXJuaW5nOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9lNjZiYTIwYWQ1YmU0MzNlYjU0NDIzZjJiMDk3ZDgyOTMyNGQ5ZGU2L3BhY2thZ2VzL2ZianMvc3JjL19fZm9ya3NfXy93YXJuaW5nLmpzXG4gKlxuICogT25seSBjaGFuZ2UgaXMgd2UgdXNlIGNvbnNvbGUud2FybiBpbnN0ZWFkIG9mIGNvbnNvbGUuZXJyb3IsXG4gKiBhbmQgZG8gbm90aGluZyB3aGVuICdjb25zb2xlJyBpcyBub3Qgc3VwcG9ydGVkLlxuICogVGhpcyByZWFsbHkgc2ltcGxpZmllcyB0aGUgY29kZS5cbiAqIC0tLVxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYGxvd1ByaW9yaXR5V2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmckMSA9IGxvd1ByaW9yaXR5V2FybmluZztcblxuZnVuY3Rpb24gdHlwZU9mKG9iamVjdCkge1xuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyICQkdHlwZW9mID0gb2JqZWN0LiQkdHlwZW9mO1xuICAgIHN3aXRjaCAoJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICB2YXIgdHlwZSA9IG9iamVjdC50eXBlO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciAkJHR5cGVvZlR5cGUgPSB0eXBlICYmIHR5cGUuJCR0eXBlb2Y7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoJCR0eXBlb2ZUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2ZUeXBlO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vLyBBc3luY01vZGUgaXMgZGVwcmVjYXRlZCBhbG9uZyB3aXRoIGlzQXN5bmNNb2RlXG52YXIgQXN5bmNNb2RlID0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xudmFyIENvbmN1cnJlbnRNb2RlID0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG52YXIgQ29udGV4dENvbnN1bWVyID0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xudmFyIENvbnRleHRQcm92aWRlciA9IFJFQUNUX1BST1ZJREVSX1RZUEU7XG52YXIgRWxlbWVudCA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcbnZhciBGb3J3YXJkUmVmID0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbnZhciBGcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG52YXIgTGF6eSA9IFJFQUNUX0xBWllfVFlQRTtcbnZhciBNZW1vID0gUkVBQ1RfTUVNT19UWVBFO1xudmFyIFBvcnRhbCA9IFJFQUNUX1BPUlRBTF9UWVBFO1xudmFyIFByb2ZpbGVyID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbnZhciBTdHJpY3RNb2RlID0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbnZhciBTdXNwZW5zZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG5cbnZhciBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IGZhbHNlO1xuXG4vLyBBc3luY01vZGUgc2hvdWxkIGJlIGRlcHJlY2F0ZWRcbmZ1bmN0aW9uIGlzQXN5bmNNb2RlKG9iamVjdCkge1xuICB7XG4gICAgaWYgKCFoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSkge1xuICAgICAgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSB0cnVlO1xuICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICdUaGUgUmVhY3RJcy5pc0FzeW5jTW9kZSgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxNysuIFVwZGF0ZSB5b3VyIGNvZGUgdG8gdXNlICcgKyAnUmVhY3RJcy5pc0NvbmN1cnJlbnRNb2RlKCkgaW5zdGVhZC4gSXQgaGFzIHRoZSBleGFjdCBzYW1lIEFQSS4nKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB8fCB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTlRFWFRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST1ZJREVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZvcndhcmRSZWYob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRnJhZ21lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTGF6eShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9MQVpZX1RZUEU7XG59XG5mdW5jdGlvbiBpc01lbW8ob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTUVNT19UWVBFO1xufVxuZnVuY3Rpb24gaXNQb3J0YWwob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUE9SVEFMX1RZUEU7XG59XG5mdW5jdGlvbiBpc1Byb2ZpbGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N0cmljdE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3VzcGVuc2Uob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbn1cblxuZXhwb3J0cy50eXBlT2YgPSB0eXBlT2Y7XG5leHBvcnRzLkFzeW5jTW9kZSA9IEFzeW5jTW9kZTtcbmV4cG9ydHMuQ29uY3VycmVudE1vZGUgPSBDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuQ29udGV4dENvbnN1bWVyID0gQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5Db250ZXh0UHJvdmlkZXIgPSBDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLkVsZW1lbnQgPSBFbGVtZW50O1xuZXhwb3J0cy5Gb3J3YXJkUmVmID0gRm9yd2FyZFJlZjtcbmV4cG9ydHMuRnJhZ21lbnQgPSBGcmFnbWVudDtcbmV4cG9ydHMuTGF6eSA9IExhenk7XG5leHBvcnRzLk1lbW8gPSBNZW1vO1xuZXhwb3J0cy5Qb3J0YWwgPSBQb3J0YWw7XG5leHBvcnRzLlByb2ZpbGVyID0gUHJvZmlsZXI7XG5leHBvcnRzLlN0cmljdE1vZGUgPSBTdHJpY3RNb2RlO1xuZXhwb3J0cy5TdXNwZW5zZSA9IFN1c3BlbnNlO1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGU7XG5leHBvcnRzLmlzQXN5bmNNb2RlID0gaXNBc3luY01vZGU7XG5leHBvcnRzLmlzQ29uY3VycmVudE1vZGUgPSBpc0NvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5pc0NvbnRleHRDb25zdW1lciA9IGlzQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5pc0NvbnRleHRQcm92aWRlciA9IGlzQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG5leHBvcnRzLmlzRm9yd2FyZFJlZiA9IGlzRm9yd2FyZFJlZjtcbmV4cG9ydHMuaXNGcmFnbWVudCA9IGlzRnJhZ21lbnQ7XG5leHBvcnRzLmlzTGF6eSA9IGlzTGF6eTtcbmV4cG9ydHMuaXNNZW1vID0gaXNNZW1vO1xuZXhwb3J0cy5pc1BvcnRhbCA9IGlzUG9ydGFsO1xuZXhwb3J0cy5pc1Byb2ZpbGVyID0gaXNQcm9maWxlcjtcbmV4cG9ydHMuaXNTdHJpY3RNb2RlID0gaXNTdHJpY3RNb2RlO1xuZXhwb3J0cy5pc1N1c3BlbnNlID0gaXNTdXNwZW5zZTtcbiAgfSkoKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-is/cjs/react-is.development.js\n");

/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ \"./node_modules/react-is/cjs/react-is.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX3VwbG9hZF9jb21wb25lbnRzLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2luZGV4LmpzPzRjZWMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDO0FBQ0QsbUJBQW1CLG1CQUFPLENBQUMsMEZBQStCO0FBQzFEIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-is/index.js\n");

/***/ }),

/***/ "./node_modules/resumablejs/resumable.js":
/*!***********************************************!*\
  !*** ./node_modules/resumablejs/resumable.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n* MIT Licensed\n* http://www.23developer.com/opensource\n* http://github.com/23/resumable.js\n* Steffen Tiedemann Christensen, steffen@23company.com\n*/\n\n(function(){\n\"use strict\";\n\n  var Resumable = function(opts){\n    if ( !(this instanceof Resumable) ) {\n      return new Resumable(opts);\n    }\n    this.version = 1.0;\n    // SUPPORTED BY BROWSER?\n    // Check if these features are support by the browser:\n    // - File object type\n    // - Blob object type\n    // - FileList object type\n    // - slicing files\n    this.support = (\n                   (typeof(File)!=='undefined')\n                   &&\n                   (typeof(Blob)!=='undefined')\n                   &&\n                   (typeof(FileList)!=='undefined')\n                   &&\n                   (!!Blob.prototype.webkitSlice||!!Blob.prototype.mozSlice||!!Blob.prototype.slice||false)\n                   );\n    if(!this.support) return(false);\n\n\n    // PROPERTIES\n    var $ = this;\n    $.files = [];\n    $.defaults = {\n      chunkSize:1*1024*1024,\n      forceChunkSize:false,\n      simultaneousUploads:3,\n      fileParameterName:'file',\n      chunkNumberParameterName: 'resumableChunkNumber',\n      chunkSizeParameterName: 'resumableChunkSize',\n      currentChunkSizeParameterName: 'resumableCurrentChunkSize',\n      totalSizeParameterName: 'resumableTotalSize',\n      typeParameterName: 'resumableType',\n      identifierParameterName: 'resumableIdentifier',\n      fileNameParameterName: 'resumableFilename',\n      relativePathParameterName: 'resumableRelativePath',\n      totalChunksParameterName: 'resumableTotalChunks',\n      throttleProgressCallbacks: 0.5,\n      query:{},\n      headers:{},\n      preprocess:null,\n      method:'multipart',\n      uploadMethod: 'POST',\n      testMethod: 'GET',\n      prioritizeFirstAndLastChunk:false,\n      target:'/',\n      testTarget: null,\n      parameterNamespace:'',\n      testChunks:true,\n      generateUniqueIdentifier:null,\n      getTarget:null,\n      maxChunkRetries:100,\n      chunkRetryInterval:undefined,\n      permanentErrors:[400, 404, 415, 500, 501],\n      maxFiles:undefined,\n      withCredentials:false,\n      xhrTimeout:0,\n      clearInput:true,\n      chunkFormat:'blob',\n      setChunkTypeFromFile:false,\n      maxFilesErrorCallback:function (files, errorCount) {\n        var maxFiles = $.getOpt('maxFiles');\n        alert('Please upload no more than ' + maxFiles + ' file' + (maxFiles === 1 ? '' : 's') + ' at a time.');\n      },\n      minFileSize:1,\n      minFileSizeErrorCallback:function(file, errorCount) {\n        alert(file.fileName||file.name +' is too small, please upload files larger than ' + $h.formatSize($.getOpt('minFileSize')) + '.');\n      },\n      maxFileSize:undefined,\n      maxFileSizeErrorCallback:function(file, errorCount) {\n        alert(file.fileName||file.name +' is too large, please upload files less than ' + $h.formatSize($.getOpt('maxFileSize')) + '.');\n      },\n      fileType: [],\n      fileTypeErrorCallback: function(file, errorCount) {\n        alert(file.fileName||file.name +' has type not allowed, please upload files of type ' + $.getOpt('fileType') + '.');\n      }\n    };\n    $.opts = opts||{};\n    $.getOpt = function(o) {\n      var $opt = this;\n      // Get multiple option if passed an array\n      if(o instanceof Array) {\n        var options = {};\n        $h.each(o, function(option){\n          options[option] = $opt.getOpt(option);\n        });\n        return options;\n      }\n      // Otherwise, just return a simple option\n      if ($opt instanceof ResumableChunk) {\n        if (typeof $opt.opts[o] !== 'undefined') { return $opt.opts[o]; }\n        else { $opt = $opt.fileObj; }\n      }\n      if ($opt instanceof ResumableFile) {\n        if (typeof $opt.opts[o] !== 'undefined') { return $opt.opts[o]; }\n        else { $opt = $opt.resumableObj; }\n      }\n      if ($opt instanceof Resumable) {\n        if (typeof $opt.opts[o] !== 'undefined') { return $opt.opts[o]; }\n        else { return $opt.defaults[o]; }\n      }\n    };\n\n    // EVENTS\n    // catchAll(event, ...)\n    // fileSuccess(file), fileProgress(file), fileAdded(file, event), filesAdded(files, filesSkipped), fileRetry(file),\n    // fileError(file, message), complete(), progress(), error(message, file), pause()\n    $.events = [];\n    $.on = function(event,callback){\n      $.events.push(event.toLowerCase(), callback);\n    };\n    $.fire = function(){\n      // `arguments` is an object, not array, in FF, so:\n      var args = [];\n      for (var i=0; i<arguments.length; i++) args.push(arguments[i]);\n      // Find event listeners, and support pseudo-event `catchAll`\n      var event = args[0].toLowerCase();\n      for (var i=0; i<=$.events.length; i+=2) {\n        if($.events[i]==event) $.events[i+1].apply($,args.slice(1));\n        if($.events[i]=='catchall') $.events[i+1].apply(null,args);\n      }\n      if(event=='fileerror') $.fire('error', args[2], args[1]);\n      if(event=='fileprogress') $.fire('progress');\n    };\n\n\n    // INTERNAL HELPER METHODS (handy, but ultimately not part of uploading)\n    var $h = {\n      stopEvent: function(e){\n        e.stopPropagation();\n        e.preventDefault();\n      },\n      each: function(o,callback){\n        if(typeof(o.length)!=='undefined') {\n          for (var i=0; i<o.length; i++) {\n            // Array or FileList\n            if(callback(o[i])===false) return;\n          }\n        } else {\n          for (i in o) {\n            // Object\n            if(callback(i,o[i])===false) return;\n          }\n        }\n      },\n      generateUniqueIdentifier:function(file, event){\n        var custom = $.getOpt('generateUniqueIdentifier');\n        if(typeof custom === 'function') {\n          return custom(file, event);\n        }\n        var relativePath = file.webkitRelativePath||file.fileName||file.name; // Some confusion in different versions of Firefox\n        var size = file.size;\n        return(size + '-' + relativePath.replace(/[^0-9a-zA-Z_-]/img, ''));\n      },\n      contains:function(array,test) {\n        var result = false;\n\n        $h.each(array, function(value) {\n          if (value == test) {\n            result = true;\n            return false;\n          }\n          return true;\n        });\n\n        return result;\n      },\n      formatSize:function(size){\n        if(size<1024) {\n          return size + ' bytes';\n        } else if(size<1024*1024) {\n          return (size/1024.0).toFixed(0) + ' KB';\n        } else if(size<1024*1024*1024) {\n          return (size/1024.0/1024.0).toFixed(1) + ' MB';\n        } else {\n          return (size/1024.0/1024.0/1024.0).toFixed(1) + ' GB';\n        }\n      },\n      getTarget:function(request, params){\n        var target = $.getOpt('target');\n\n        if (request === 'test' && $.getOpt('testTarget')) {\n          target = $.getOpt('testTarget') === '/' ? $.getOpt('target') : $.getOpt('testTarget');\n        }\n\n        if (typeof target === 'function') {\n          return target(params);\n        }\n\n        var separator = target.indexOf('?') < 0 ? '?' : '&';\n        var joinedParams = params.join('&');\n\n        return target + separator + joinedParams;\n      }\n    };\n\n    var onDrop = function(event){\n      $h.stopEvent(event);\n\n      //handle dropped things as items if we can (this lets us deal with folders nicer in some cases)\n      if (event.dataTransfer && event.dataTransfer.items) {\n        loadFiles(event.dataTransfer.items, event);\n      }\n      //else handle them as files\n      else if (event.dataTransfer && event.dataTransfer.files) {\n        loadFiles(event.dataTransfer.files, event);\n      }\n    };\n    var preventDefault = function(e) {\n      e.preventDefault();\n    };\n\n    /**\n     * processes a single upload item (file or directory)\n     * @param {Object} item item to upload, may be file or directory entry\n     * @param {string} path current file path\n     * @param {File[]} items list of files to append new items to\n     * @param {Function} cb callback invoked when item is processed\n     */\n    function processItem(item, path, items, cb) {\n      var entry;\n      if(item.isFile){\n        // file provided\n        return item.file(function(file){\n          file.relativePath = path + file.name;\n          items.push(file);\n          cb();\n        });\n      }else if(item.isDirectory){\n        // item is already a directory entry, just assign\n        entry = item;\n      }else if(item instanceof File) {\n        items.push(item);\n      }\n      if('function' === typeof item.webkitGetAsEntry){\n        // get entry from file object\n        entry = item.webkitGetAsEntry();\n      }\n      if(entry && entry.isDirectory){\n        // directory provided, process it\n        return processDirectory(entry, path + entry.name + '/', items, cb);\n      }\n      if('function' === typeof item.getAsFile){\n        // item represents a File object, convert it\n        item = item.getAsFile();\n        if(item instanceof File) {\n          item.relativePath = path + item.name;\n          items.push(item);\n        }\n      }\n      cb(); // indicate processing is done\n    }\n\n\n    /**\n     * cps-style list iteration.\n     * invokes all functions in list and waits for their callback to be\n     * triggered.\n     * @param  {Function[]}   items list of functions expecting callback parameter\n     * @param  {Function} cb    callback to trigger after the last callback has been invoked\n     */\n    function processCallbacks(items, cb){\n      if(!items || items.length === 0){\n        // empty or no list, invoke callback\n        return cb();\n      }\n      // invoke current function, pass the next part as continuation\n      items[0](function(){\n        processCallbacks(items.slice(1), cb);\n      });\n    }\n\n    /**\n     * recursively traverse directory and collect files to upload\n     * @param  {Object}   directory directory to process\n     * @param  {string}   path      current path\n     * @param  {File[]}   items     target list of items\n     * @param  {Function} cb        callback invoked after traversing directory\n     */\n    function processDirectory (directory, path, items, cb) {\n      var dirReader = directory.createReader();\n      dirReader.readEntries(function(entries){\n        if(!entries.length){\n          // empty directory, skip\n          return cb();\n        }\n        // process all conversion callbacks, finally invoke own one\n        processCallbacks(\n          entries.map(function(entry){\n            // bind all properties except for callback\n            return processItem.bind(null, entry, path, items);\n          }),\n          cb\n        );\n      });\n    }\n\n    /**\n     * process items to extract files to be uploaded\n     * @param  {File[]} items items to process\n     * @param  {Event} event event that led to upload\n     */\n    function loadFiles(items, event) {\n      if(!items.length){\n        return; // nothing to do\n      }\n      $.fire('beforeAdd');\n      var files = [];\n      processCallbacks(\n          Array.prototype.map.call(items, function(item){\n            // bind all properties except for callback\n            return processItem.bind(null, item, \"\", files);\n          }),\n          function(){\n            if(files.length){\n              // at least one file found\n              appendFilesFromFileList(files, event);\n            }\n          }\n      );\n    };\n\n    var appendFilesFromFileList = function(fileList, event){\n      // check for uploading too many files\n      var errorCount = 0;\n      var o = $.getOpt(['maxFiles', 'minFileSize', 'maxFileSize', 'maxFilesErrorCallback', 'minFileSizeErrorCallback', 'maxFileSizeErrorCallback', 'fileType', 'fileTypeErrorCallback']);\n      if (typeof(o.maxFiles)!=='undefined' && o.maxFiles<(fileList.length+$.files.length)) {\n        // if single-file upload, file is already added, and trying to add 1 new file, simply replace the already-added file\n        if (o.maxFiles===1 && $.files.length===1 && fileList.length===1) {\n          $.removeFile($.files[0]);\n        } else {\n          o.maxFilesErrorCallback(fileList, errorCount++);\n          return false;\n        }\n      }\n      var files = [], filesSkipped = [], remaining = fileList.length;\n      var decreaseReamining = function(){\n        if(!--remaining){\n          // all files processed, trigger event\n          if(!files.length && !filesSkipped.length){\n            // no succeeded files, just skip\n            return;\n          }\n          window.setTimeout(function(){\n            $.fire('filesAdded', files, filesSkipped);\n          },0);\n        }\n      };\n      $h.each(fileList, function(file){\n        var fileName = file.name;\n        if(o.fileType.length > 0){\n          var fileTypeFound = false;\n          for(var index in o.fileType){\n            var extension = '.' + o.fileType[index];\n\t\t\tif(fileName.toLowerCase().indexOf(extension.toLowerCase(), fileName.length - extension.length) !== -1){\n              fileTypeFound = true;\n              break;\n            }\n          }\n          if (!fileTypeFound) {\n            o.fileTypeErrorCallback(file, errorCount++);\n            return false;\n          }\n        }\n\n        if (typeof(o.minFileSize)!=='undefined' && file.size<o.minFileSize) {\n          o.minFileSizeErrorCallback(file, errorCount++);\n          return false;\n        }\n        if (typeof(o.maxFileSize)!=='undefined' && file.size>o.maxFileSize) {\n          o.maxFileSizeErrorCallback(file, errorCount++);\n          return false;\n        }\n\n        function addFile(uniqueIdentifier){\n          if (!$.getFromUniqueIdentifier(uniqueIdentifier)) {(function(){\n            file.uniqueIdentifier = uniqueIdentifier;\n            var f = new ResumableFile($, file, uniqueIdentifier);\n            $.files.push(f);\n            files.push(f);\n            f.container = (typeof event != 'undefined' ? event.srcElement : null);\n            window.setTimeout(function(){\n              $.fire('fileAdded', f, event)\n            },0);\n          })()} else {\n            filesSkipped.push(file);\n          };\n          decreaseReamining();\n        }\n        // directories have size == 0\n        var uniqueIdentifier = $h.generateUniqueIdentifier(file, event);\n        if(uniqueIdentifier && typeof uniqueIdentifier.then === 'function'){\n          // Promise or Promise-like object provided as unique identifier\n          uniqueIdentifier\n          .then(\n            function(uniqueIdentifier){\n              // unique identifier generation succeeded\n              addFile(uniqueIdentifier);\n            },\n           function(){\n              // unique identifier generation failed\n              // skip further processing, only decrease file count\n              decreaseReamining();\n            }\n          );\n        }else{\n          // non-Promise provided as unique identifier, process synchronously\n          addFile(uniqueIdentifier);\n        }\n      });\n    };\n\n    // INTERNAL OBJECT TYPES\n    function ResumableFile(resumableObj, file, uniqueIdentifier){\n      var $ = this;\n      $.opts = {};\n      $.getOpt = resumableObj.getOpt;\n      $._prevProgress = 0;\n      $.resumableObj = resumableObj;\n      $.file = file;\n      $.fileName = file.fileName||file.name; // Some confusion in different versions of Firefox\n      $.size = file.size;\n      $.relativePath = file.relativePath || file.webkitRelativePath || $.fileName;\n      $.uniqueIdentifier = uniqueIdentifier;\n      $._pause = false;\n      $.container = '';\n      var _error = uniqueIdentifier !== undefined;\n\n      // Callback when something happens within the chunk\n      var chunkEvent = function(event, message){\n        // event can be 'progress', 'success', 'error' or 'retry'\n        switch(event){\n        case 'progress':\n          $.resumableObj.fire('fileProgress', $, message);\n          break;\n        case 'error':\n          $.abort();\n          _error = true;\n          $.chunks = [];\n          $.resumableObj.fire('fileError', $, message);\n          break;\n        case 'success':\n          if(_error) return;\n          $.resumableObj.fire('fileProgress', $); // it's at least progress\n          if($.isComplete()) {\n            $.resumableObj.fire('fileSuccess', $, message);\n          }\n          break;\n        case 'retry':\n          $.resumableObj.fire('fileRetry', $);\n          break;\n        }\n      };\n\n      // Main code to set up a file object with chunks,\n      // packaged to be able to handle retries if needed.\n      $.chunks = [];\n      $.abort = function(){\n        // Stop current uploads\n        var abortCount = 0;\n        $h.each($.chunks, function(c){\n          if(c.status()=='uploading') {\n            c.abort();\n            abortCount++;\n          }\n        });\n        if(abortCount>0) $.resumableObj.fire('fileProgress', $);\n      };\n      $.cancel = function(){\n        // Reset this file to be void\n        var _chunks = $.chunks;\n        $.chunks = [];\n        // Stop current uploads\n        $h.each(_chunks, function(c){\n          if(c.status()=='uploading')  {\n            c.abort();\n            $.resumableObj.uploadNextChunk();\n          }\n        });\n        $.resumableObj.removeFile($);\n        $.resumableObj.fire('fileProgress', $);\n      };\n      $.retry = function(){\n        $.bootstrap();\n        var firedRetry = false;\n        $.resumableObj.on('chunkingComplete', function(){\n          if(!firedRetry) $.resumableObj.upload();\n          firedRetry = true;\n        });\n      };\n      $.bootstrap = function(){\n        $.abort();\n        _error = false;\n        // Rebuild stack of chunks from file\n        $.chunks = [];\n        $._prevProgress = 0;\n        var round = $.getOpt('forceChunkSize') ? Math.ceil : Math.floor;\n        var maxOffset = Math.max(round($.file.size/$.getOpt('chunkSize')),1);\n        for (var offset=0; offset<maxOffset; offset++) {(function(offset){\n            window.setTimeout(function(){\n                $.chunks.push(new ResumableChunk($.resumableObj, $, offset, chunkEvent));\n                $.resumableObj.fire('chunkingProgress',$,offset/maxOffset);\n            },0);\n        })(offset)}\n        window.setTimeout(function(){\n            $.resumableObj.fire('chunkingComplete',$);\n        },0);\n      };\n      $.progress = function(){\n        if(_error) return(1);\n        // Sum up progress across everything\n        var ret = 0;\n        var error = false;\n        $h.each($.chunks, function(c){\n          if(c.status()=='error') error = true;\n          ret += c.progress(true); // get chunk progress relative to entire file\n        });\n        ret = (error ? 1 : (ret>0.99999 ? 1 : ret));\n        ret = Math.max($._prevProgress, ret); // We don't want to lose percentages when an upload is paused\n        $._prevProgress = ret;\n        return(ret);\n      };\n      $.isUploading = function(){\n        var uploading = false;\n        $h.each($.chunks, function(chunk){\n          if(chunk.status()=='uploading') {\n            uploading = true;\n            return(false);\n          }\n        });\n        return(uploading);\n      };\n      $.isComplete = function(){\n        var outstanding = false;\n        $h.each($.chunks, function(chunk){\n          var status = chunk.status();\n          if(status=='pending' || status=='uploading' || chunk.preprocessState === 1) {\n            outstanding = true;\n            return(false);\n          }\n        });\n        return(!outstanding);\n      };\n      $.pause = function(pause){\n          if(typeof(pause)==='undefined'){\n              $._pause = ($._pause ? false : true);\n          }else{\n              $._pause = pause;\n          }\n      };\n      $.isPaused = function() {\n        return $._pause;\n      };\n\n\n      // Bootstrap and return\n      $.resumableObj.fire('chunkingStart', $);\n      $.bootstrap();\n      return(this);\n    }\n\n\n    function ResumableChunk(resumableObj, fileObj, offset, callback){\n      var $ = this;\n      $.opts = {};\n      $.getOpt = resumableObj.getOpt;\n      $.resumableObj = resumableObj;\n      $.fileObj = fileObj;\n      $.fileObjSize = fileObj.size;\n      $.fileObjType = fileObj.file.type;\n      $.offset = offset;\n      $.callback = callback;\n      $.lastProgressCallback = (new Date);\n      $.tested = false;\n      $.retries = 0;\n      $.pendingRetry = false;\n      $.preprocessState = 0; // 0 = unprocessed, 1 = processing, 2 = finished\n\n      // Computed properties\n      var chunkSize = $.getOpt('chunkSize');\n      $.loaded = 0;\n      $.startByte = $.offset*chunkSize;\n      $.endByte = Math.min($.fileObjSize, ($.offset+1)*chunkSize);\n      if ($.fileObjSize-$.endByte < chunkSize && !$.getOpt('forceChunkSize')) {\n        // The last chunk will be bigger than the chunk size, but less than 2*chunkSize\n        $.endByte = $.fileObjSize;\n      }\n      $.xhr = null;\n\n      // test() makes a GET request without any data to see if the chunk has already been uploaded in a previous session\n      $.test = function(){\n        // Set up request and listen for event\n        $.xhr = new XMLHttpRequest();\n\n        var testHandler = function(e){\n          $.tested = true;\n          var status = $.status();\n          if(status=='success') {\n            $.callback(status, $.message());\n            $.resumableObj.uploadNextChunk();\n          } else {\n            $.send();\n          }\n        };\n        $.xhr.addEventListener('load', testHandler, false);\n        $.xhr.addEventListener('error', testHandler, false);\n        $.xhr.addEventListener('timeout', testHandler, false);\n\n        // Add data from the query options\n        var params = [];\n        var parameterNamespace = $.getOpt('parameterNamespace');\n        var customQuery = $.getOpt('query');\n        if(typeof customQuery == 'function') customQuery = customQuery($.fileObj, $);\n        $h.each(customQuery, function(k,v){\n          params.push([encodeURIComponent(parameterNamespace+k), encodeURIComponent(v)].join('='));\n        });\n        // Add extra data to identify chunk\n        params = params.concat(\n          [\n            // define key/value pairs for additional parameters\n            ['chunkNumberParameterName', $.offset + 1],\n            ['chunkSizeParameterName', $.getOpt('chunkSize')],\n            ['currentChunkSizeParameterName', $.endByte - $.startByte],\n            ['totalSizeParameterName', $.fileObjSize],\n            ['typeParameterName', $.fileObjType],\n            ['identifierParameterName', $.fileObj.uniqueIdentifier],\n            ['fileNameParameterName', $.fileObj.fileName],\n            ['relativePathParameterName', $.fileObj.relativePath],\n            ['totalChunksParameterName', $.fileObj.chunks.length]\n          ].filter(function(pair){\n            // include items that resolve to truthy values\n            // i.e. exclude false, null, undefined and empty strings\n            return $.getOpt(pair[0]);\n          })\n          .map(function(pair){\n            // map each key/value pair to its final form\n            return [\n              parameterNamespace + $.getOpt(pair[0]),\n              encodeURIComponent(pair[1])\n            ].join('=');\n          })\n        );\n        // Append the relevant chunk and send it\n        $.xhr.open($.getOpt('testMethod'), $h.getTarget('test', params));\n        $.xhr.timeout = $.getOpt('xhrTimeout');\n        $.xhr.withCredentials = $.getOpt('withCredentials');\n        // Add data from header options\n        var customHeaders = $.getOpt('headers');\n        if(typeof customHeaders === 'function') {\n          customHeaders = customHeaders($.fileObj, $);\n        }\n        $h.each(customHeaders, function(k,v) {\n          $.xhr.setRequestHeader(k, v);\n        });\n        $.xhr.send(null);\n      };\n\n      $.preprocessFinished = function(){\n        $.preprocessState = 2;\n        $.send();\n      };\n\n      // send() uploads the actual data in a POST call\n      $.send = function(){\n        var preprocess = $.getOpt('preprocess');\n        if(typeof preprocess === 'function') {\n          switch($.preprocessState) {\n          case 0: $.preprocessState = 1; preprocess($); return;\n          case 1: return;\n          case 2: break;\n          }\n        }\n        if($.getOpt('testChunks') && !$.tested) {\n          $.test();\n          return;\n        }\n\n        // Set up request and listen for event\n        $.xhr = new XMLHttpRequest();\n\n        // Progress\n        $.xhr.upload.addEventListener('progress', function(e){\n          if( (new Date) - $.lastProgressCallback > $.getOpt('throttleProgressCallbacks') * 1000 ) {\n            $.callback('progress');\n            $.lastProgressCallback = (new Date);\n          }\n          $.loaded=e.loaded||0;\n        }, false);\n        $.loaded = 0;\n        $.pendingRetry = false;\n        $.callback('progress');\n\n        // Done (either done, failed or retry)\n        var doneHandler = function(e){\n          var status = $.status();\n          if(status=='success'||status=='error') {\n            $.callback(status, $.message());\n            $.resumableObj.uploadNextChunk();\n          } else {\n            $.callback('retry', $.message());\n            $.abort();\n            $.retries++;\n            var retryInterval = $.getOpt('chunkRetryInterval');\n            if(retryInterval !== undefined) {\n              $.pendingRetry = true;\n              setTimeout($.send, retryInterval);\n            } else {\n              $.send();\n            }\n          }\n        };\n        $.xhr.addEventListener('load', doneHandler, false);\n        $.xhr.addEventListener('error', doneHandler, false);\n        $.xhr.addEventListener('timeout', doneHandler, false);\n\n        // Set up the basic query data from Resumable\n        var query = [\n          ['chunkNumberParameterName', $.offset + 1],\n          ['chunkSizeParameterName', $.getOpt('chunkSize')],\n          ['currentChunkSizeParameterName', $.endByte - $.startByte],\n          ['totalSizeParameterName', $.fileObjSize],\n          ['typeParameterName', $.fileObjType],\n          ['identifierParameterName', $.fileObj.uniqueIdentifier],\n          ['fileNameParameterName', $.fileObj.fileName],\n          ['relativePathParameterName', $.fileObj.relativePath],\n          ['totalChunksParameterName', $.fileObj.chunks.length],\n        ].filter(function(pair){\n          // include items that resolve to truthy values\n          // i.e. exclude false, null, undefined and empty strings\n          return $.getOpt(pair[0]);\n        })\n        .reduce(function(query, pair){\n          // assign query key/value\n          query[$.getOpt(pair[0])] = pair[1];\n          return query;\n        }, {});\n        // Mix in custom data\n        var customQuery = $.getOpt('query');\n        if(typeof customQuery == 'function') customQuery = customQuery($.fileObj, $);\n        $h.each(customQuery, function(k,v){\n          query[k] = v;\n        });\n\n        var func = ($.fileObj.file.slice ? 'slice' : ($.fileObj.file.mozSlice ? 'mozSlice' : ($.fileObj.file.webkitSlice ? 'webkitSlice' : 'slice')));\n        var bytes = $.fileObj.file[func]($.startByte, $.endByte, $.getOpt('setChunkTypeFromFile') ? $.fileObj.file.type : \"\");\n        var data = null;\n        var params = [];\n\n        var parameterNamespace = $.getOpt('parameterNamespace');\n                if ($.getOpt('method') === 'octet') {\n                    // Add data from the query options\n                    data = bytes;\n                    $h.each(query, function (k, v) {\n                        params.push([encodeURIComponent(parameterNamespace + k), encodeURIComponent(v)].join('='));\n                    });\n                } else {\n                    // Add data from the query options\n                    data = new FormData();\n                    $h.each(query, function (k, v) {\n                        data.append(parameterNamespace + k, v);\n                        params.push([encodeURIComponent(parameterNamespace + k), encodeURIComponent(v)].join('='));\n                    });\n                    if ($.getOpt('chunkFormat') == 'blob') {\n                        data.append(parameterNamespace + $.getOpt('fileParameterName'), bytes, $.fileObj.fileName);\n                    }\n                    else if ($.getOpt('chunkFormat') == 'base64') {\n                        var fr = new FileReader();\n                        fr.onload = function (e) {\n                            data.append(parameterNamespace + $.getOpt('fileParameterName'), fr.result);\n                            $.xhr.send(data);\n                        }\n                        fr.readAsDataURL(bytes);\n                    }\n                }\n\n        var target = $h.getTarget('upload', params);\n        var method = $.getOpt('uploadMethod');\n\n        $.xhr.open(method, target);\n        if ($.getOpt('method') === 'octet') {\n          $.xhr.setRequestHeader('Content-Type', 'application/octet-stream');\n        }\n        $.xhr.timeout = $.getOpt('xhrTimeout');\n        $.xhr.withCredentials = $.getOpt('withCredentials');\n        // Add data from header options\n        var customHeaders = $.getOpt('headers');\n        if(typeof customHeaders === 'function') {\n          customHeaders = customHeaders($.fileObj, $);\n        }\n\n        $h.each(customHeaders, function(k,v) {\n          $.xhr.setRequestHeader(k, v);\n        });\n\n                if ($.getOpt('chunkFormat') == 'blob') {\n                    $.xhr.send(data);\n                }\n      };\n      $.abort = function(){\n        // Abort and reset\n        if($.xhr) $.xhr.abort();\n        $.xhr = null;\n      };\n      $.status = function(){\n        // Returns: 'pending', 'uploading', 'success', 'error'\n        if($.pendingRetry) {\n          // if pending retry then that's effectively the same as actively uploading,\n          // there might just be a slight delay before the retry starts\n          return('uploading');\n        } else if(!$.xhr) {\n          return('pending');\n        } else if($.xhr.readyState<4) {\n          // Status is really 'OPENED', 'HEADERS_RECEIVED' or 'LOADING' - meaning that stuff is happening\n          return('uploading');\n        } else {\n          if($.xhr.status == 200 || $.xhr.status == 201) {\n            // HTTP 200, 201 (created)\n            return('success');\n          } else if($h.contains($.getOpt('permanentErrors'), $.xhr.status) || $.retries >= $.getOpt('maxChunkRetries')) {\n            // HTTP 415/500/501, permanent error\n            return('error');\n          } else {\n            // this should never happen, but we'll reset and queue a retry\n            // a likely case for this would be 503 service unavailable\n            $.abort();\n            return('pending');\n          }\n        }\n      };\n      $.message = function(){\n        return($.xhr ? $.xhr.responseText : '');\n      };\n      $.progress = function(relative){\n        if(typeof(relative)==='undefined') relative = false;\n        var factor = (relative ? ($.endByte-$.startByte)/$.fileObjSize : 1);\n        if($.pendingRetry) return(0);\n        if(!$.xhr || !$.xhr.status) factor*=.95;\n        var s = $.status();\n        switch(s){\n        case 'success':\n        case 'error':\n          return(1*factor);\n        case 'pending':\n          return(0*factor);\n        default:\n          return($.loaded/($.endByte-$.startByte)*factor);\n        }\n      };\n      return(this);\n    }\n\n    // QUEUE\n    $.uploadNextChunk = function(){\n      var found = false;\n\n      // In some cases (such as videos) it's really handy to upload the first\n      // and last chunk of a file quickly; this let's the server check the file's\n      // metadata and determine if there's even a point in continuing.\n      if ($.getOpt('prioritizeFirstAndLastChunk')) {\n        $h.each($.files, function(file){\n          if(file.chunks.length && file.chunks[0].status()=='pending' && file.chunks[0].preprocessState === 0) {\n            file.chunks[0].send();\n            found = true;\n            return(false);\n          }\n          if(file.chunks.length>1 && file.chunks[file.chunks.length-1].status()=='pending' && file.chunks[file.chunks.length-1].preprocessState === 0) {\n            file.chunks[file.chunks.length-1].send();\n            found = true;\n            return(false);\n          }\n        });\n        if(found) return(true);\n      }\n\n      // Now, simply look for the next, best thing to upload\n      $h.each($.files, function(file){\n        if(file.isPaused()===false){\n         $h.each(file.chunks, function(chunk){\n           if(chunk.status()=='pending' && chunk.preprocessState === 0) {\n             chunk.send();\n             found = true;\n             return(false);\n           }\n          });\n        }\n        if(found) return(false);\n      });\n      if(found) return(true);\n\n      // The are no more outstanding chunks to upload, check is everything is done\n      var outstanding = false;\n      $h.each($.files, function(file){\n        if(!file.isComplete()) {\n          outstanding = true;\n          return(false);\n        }\n      });\n      if(!outstanding) {\n        // All chunks have been uploaded, complete\n        $.fire('complete');\n      }\n      return(false);\n    };\n\n\n    // PUBLIC METHODS FOR RESUMABLE.JS\n    $.assignBrowse = function(domNodes, isDirectory){\n      if(typeof(domNodes.length)=='undefined') domNodes = [domNodes];\n\n      $h.each(domNodes, function(domNode) {\n        var input;\n        if(domNode.tagName==='INPUT' && domNode.type==='file'){\n          input = domNode;\n        } else {\n          input = document.createElement('input');\n          input.setAttribute('type', 'file');\n          input.style.display = 'none';\n          domNode.addEventListener('click', function(){\n            input.style.opacity = 0;\n            input.style.display='block';\n            input.focus();\n            input.click();\n            input.style.display='none';\n          }, false);\n          domNode.appendChild(input);\n        }\n        var maxFiles = $.getOpt('maxFiles');\n        if (typeof(maxFiles)==='undefined'||maxFiles!=1){\n          input.setAttribute('multiple', 'multiple');\n        } else {\n          input.removeAttribute('multiple');\n        }\n        if(isDirectory){\n          input.setAttribute('webkitdirectory', 'webkitdirectory');\n        } else {\n          input.removeAttribute('webkitdirectory');\n        }\n        var fileTypes = $.getOpt('fileType');\n        if (typeof (fileTypes) !== 'undefined' && fileTypes.length >= 1) {\n          input.setAttribute('accept', fileTypes.map(function (e) { return '.' + e }).join(','));\n        }\n        else {\n          input.removeAttribute('accept');\n        }\n        // When new files are added, simply append them to the overall list\n        input.addEventListener('change', function(e){\n          appendFilesFromFileList(e.target.files,e);\n          var clearInput = $.getOpt('clearInput');\n          if (clearInput) {\n            e.target.value = '';\n          }\n        }, false);\n      });\n    };\n    $.assignDrop = function(domNodes){\n      if(typeof(domNodes.length)=='undefined') domNodes = [domNodes];\n\n      $h.each(domNodes, function(domNode) {\n        domNode.addEventListener('dragover', preventDefault, false);\n        domNode.addEventListener('dragenter', preventDefault, false);\n        domNode.addEventListener('drop', onDrop, false);\n      });\n    };\n    $.unAssignDrop = function(domNodes) {\n      if (typeof(domNodes.length) == 'undefined') domNodes = [domNodes];\n\n      $h.each(domNodes, function(domNode) {\n        domNode.removeEventListener('dragover', preventDefault);\n        domNode.removeEventListener('dragenter', preventDefault);\n        domNode.removeEventListener('drop', onDrop);\n      });\n    };\n    $.isUploading = function(){\n      var uploading = false;\n      $h.each($.files, function(file){\n        if (file.isUploading()) {\n          uploading = true;\n          return(false);\n        }\n      });\n      return(uploading);\n    };\n    $.upload = function(){\n      // Make sure we don't start too many uploads at once\n      if($.isUploading()) return;\n      // Kick off the queue\n      $.fire('uploadStart');\n      for (var num=1; num<=$.getOpt('simultaneousUploads'); num++) {\n        $.uploadNextChunk();\n      }\n    };\n    $.pause = function(){\n      // Resume all chunks currently being uploaded\n      $h.each($.files, function(file){\n        file.abort();\n      });\n      $.fire('pause');\n    };\n    $.cancel = function(){\n      $.fire('beforeCancel');\n      for(var i = $.files.length - 1; i >= 0; i--) {\n        $.files[i].cancel();\n      }\n      $.fire('cancel');\n    };\n    $.progress = function(){\n      var totalDone = 0;\n      var totalSize = 0;\n      // Resume all chunks currently being uploaded\n      $h.each($.files, function(file){\n        totalDone += file.progress()*file.size;\n        totalSize += file.size;\n      });\n      return(totalSize>0 ? totalDone/totalSize : 0);\n    };\n    $.addFile = function(file, event){\n      appendFilesFromFileList([file], event);\n    };\n    $.addFiles = function(files, event){\n      appendFilesFromFileList(files, event);\n    };\n    $.removeFile = function(file){\n      for(var i = $.files.length - 1; i >= 0; i--) {\n        if($.files[i] === file) {\n          $.files.splice(i, 1);\n        }\n      }\n    };\n    $.getFromUniqueIdentifier = function(uniqueIdentifier){\n      var ret = false;\n      $h.each($.files, function(f){\n        if(f.uniqueIdentifier==uniqueIdentifier) ret = f;\n      });\n      return(ret);\n    };\n    $.getSize = function(){\n      var totalSize = 0;\n      $h.each($.files, function(file){\n        totalSize += file.size;\n      });\n      return(totalSize);\n    };\n    $.handleDropEvent = function (e) {\n      onDrop(e);\n    };\n    $.handleChangeEvent = function (e) {\n      appendFilesFromFileList(e.target.files, e);\n      e.target.value = '';\n    };\n    $.updateQuery = function(query){\n        $.opts.query = query;\n    };\n\n    return(this);\n  };\n\n\n  // Node.js-style export for Node and Component\n  if (true) {\n    module.exports = Resumable;\n  } else {}\n\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX3VwbG9hZF9jb21wb25lbnRzLy4vbm9kZV9tb2R1bGVzL3Jlc3VtYWJsZWpzL3Jlc3VtYWJsZS5qcz9mMDU2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QscUJBQXFCO0FBQ3ZFLGNBQWMscUJBQXFCO0FBQ25DO0FBQ0E7QUFDQSxrREFBa0QscUJBQXFCO0FBQ3ZFLGNBQWMsMEJBQTBCO0FBQ3hDO0FBQ0E7QUFDQSxrREFBa0QscUJBQXFCO0FBQ3ZFLGNBQWMseUJBQXlCO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBLG1CQUFt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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZUFBZTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxpQkFBaUI7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNDQUFzQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQSxNQUFNLElBQTRCO0FBQ2xDO0FBQ0EsR0FBRyxNQUFNLEVBUU47O0FBRUgsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9yZXN1bWFibGVqcy9yZXN1bWFibGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuKiBNSVQgTGljZW5zZWRcbiogaHR0cDovL3d3dy4yM2RldmVsb3Blci5jb20vb3BlbnNvdXJjZVxuKiBodHRwOi8vZ2l0aHViLmNvbS8yMy9yZXN1bWFibGUuanNcbiogU3RlZmZlbiBUaWVkZW1hbm4gQ2hyaXN0ZW5zZW4sIHN0ZWZmZW5AMjNjb21wYW55LmNvbVxuKi9cblxuKGZ1bmN0aW9uKCl7XG5cInVzZSBzdHJpY3RcIjtcblxuICB2YXIgUmVzdW1hYmxlID0gZnVuY3Rpb24ob3B0cyl7XG4gICAgaWYgKCAhKHRoaXMgaW5zdGFuY2VvZiBSZXN1bWFibGUpICkge1xuICAgICAgcmV0dXJuIG5ldyBSZXN1bWFibGUob3B0cyk7XG4gICAgfVxuICAgIHRoaXMudmVyc2lvbiA9IDEuMDtcbiAgICAvLyBTVVBQT1JURUQgQlkgQlJPV1NFUj9cbiAgICAvLyBDaGVjayBpZiB0aGVzZSBmZWF0dXJlcyBhcmUgc3VwcG9ydCBieSB0aGUgYnJvd3NlcjpcbiAgICAvLyAtIEZpbGUgb2JqZWN0IHR5cGVcbiAgICAvLyAtIEJsb2Igb2JqZWN0IHR5cGVcbiAgICAvLyAtIEZpbGVMaXN0IG9iamVjdCB0eXBlXG4gICAgLy8gLSBzbGljaW5nIGZpbGVzXG4gICAgdGhpcy5zdXBwb3J0ID0gKFxuICAgICAgICAgICAgICAgICAgICh0eXBlb2YoRmlsZSkhPT0ndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICAgICAmJlxuICAgICAgICAgICAgICAgICAgICh0eXBlb2YoQmxvYikhPT0ndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICAgICAmJlxuICAgICAgICAgICAgICAgICAgICh0eXBlb2YoRmlsZUxpc3QpIT09J3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgICAgJiZcbiAgICAgICAgICAgICAgICAgICAoISFCbG9iLnByb3RvdHlwZS53ZWJraXRTbGljZXx8ISFCbG9iLnByb3RvdHlwZS5tb3pTbGljZXx8ISFCbG9iLnByb3RvdHlwZS5zbGljZXx8ZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgKTtcbiAgICBpZighdGhpcy5zdXBwb3J0KSByZXR1cm4oZmFsc2UpO1xuXG5cbiAgICAvLyBQUk9QRVJUSUVTXG4gICAgdmFyICQgPSB0aGlzO1xuICAgICQuZmlsZXMgPSBbXTtcbiAgICAkLmRlZmF1bHRzID0ge1xuICAgICAgY2h1bmtTaXplOjEqMTAyNCoxMDI0LFxuICAgICAgZm9yY2VDaHVua1NpemU6ZmFsc2UsXG4gICAgICBzaW11bHRhbmVvdXNVcGxvYWRzOjMsXG4gICAgICBmaWxlUGFyYW1ldGVyTmFtZTonZmlsZScsXG4gICAgICBjaHVua051bWJlclBhcmFtZXRlck5hbWU6ICdyZXN1bWFibGVDaHVua051bWJlcicsXG4gICAgICBjaHVua1NpemVQYXJhbWV0ZXJOYW1lOiAncmVzdW1hYmxlQ2h1bmtTaXplJyxcbiAgICAgIGN1cnJlbnRDaHVua1NpemVQYXJhbWV0ZXJOYW1lOiAncmVzdW1hYmxlQ3VycmVudENodW5rU2l6ZScsXG4gICAgICB0b3RhbFNpemVQYXJhbWV0ZXJOYW1lOiAncmVzdW1hYmxlVG90YWxTaXplJyxcbiAgICAgIHR5cGVQYXJhbWV0ZXJOYW1lOiAncmVzdW1hYmxlVHlwZScsXG4gICAgICBpZGVudGlmaWVyUGFyYW1ldGVyTmFtZTogJ3Jlc3VtYWJsZUlkZW50aWZpZXInLFxuICAgICAgZmlsZU5hbWVQYXJhbWV0ZXJOYW1lOiAncmVzdW1hYmxlRmlsZW5hbWUnLFxuICAgICAgcmVsYXRpdmVQYXRoUGFyYW1ldGVyTmFtZTogJ3Jlc3VtYWJsZVJlbGF0aXZlUGF0aCcsXG4gICAgICB0b3RhbENodW5rc1BhcmFtZXRlck5hbWU6ICdyZXN1bWFibGVUb3RhbENodW5rcycsXG4gICAgICB0aHJvdHRsZVByb2dyZXNzQ2FsbGJhY2tzOiAwLjUsXG4gICAgICBxdWVyeTp7fSxcbiAgICAgIGhlYWRlcnM6e30sXG4gICAgICBwcmVwcm9jZXNzOm51bGwsXG4gICAgICBtZXRob2Q6J211bHRpcGFydCcsXG4gICAgICB1cGxvYWRNZXRob2Q6ICdQT1NUJyxcbiAgICAgIHRlc3RNZXRob2Q6ICdHRVQnLFxuICAgICAgcHJpb3JpdGl6ZUZpcnN0QW5kTGFzdENodW5rOmZhbHNlLFxuICAgICAgdGFyZ2V0OicvJyxcbiAgICAgIHRlc3RUYXJnZXQ6IG51bGwsXG4gICAgICBwYXJhbWV0ZXJOYW1lc3BhY2U6JycsXG4gICAgICB0ZXN0Q2h1bmtzOnRydWUsXG4gICAgICBnZW5lcmF0ZVVuaXF1ZUlkZW50aWZpZXI6bnVsbCxcbiAgICAgIGdldFRhcmdldDpudWxsLFxuICAgICAgbWF4Q2h1bmtSZXRyaWVzOjEwMCxcbiAgICAgIGNodW5rUmV0cnlJbnRlcnZhbDp1bmRlZmluZWQsXG4gICAgICBwZXJtYW5lbnRFcnJvcnM6WzQwMCwgNDA0LCA0MTUsIDUwMCwgNTAxXSxcbiAgICAgIG1heEZpbGVzOnVuZGVmaW5lZCxcbiAgICAgIHdpdGhDcmVkZW50aWFsczpmYWxzZSxcbiAgICAgIHhoclRpbWVvdXQ6MCxcbiAgICAgIGNsZWFySW5wdXQ6dHJ1ZSxcbiAgICAgIGNodW5rRm9ybWF0OidibG9iJyxcbiAgICAgIHNldENodW5rVHlwZUZyb21GaWxlOmZhbHNlLFxuICAgICAgbWF4RmlsZXNFcnJvckNhbGxiYWNrOmZ1bmN0aW9uIChmaWxlcywgZXJyb3JDb3VudCkge1xuICAgICAgICB2YXIgbWF4RmlsZXMgPSAkLmdldE9wdCgnbWF4RmlsZXMnKTtcbiAgICAgICAgYWxlcnQoJ1BsZWFzZSB1cGxvYWQgbm8gbW9yZSB0aGFuICcgKyBtYXhGaWxlcyArICcgZmlsZScgKyAobWF4RmlsZXMgPT09IDEgPyAnJyA6ICdzJykgKyAnIGF0IGEgdGltZS4nKTtcbiAgICAgIH0sXG4gICAgICBtaW5GaWxlU2l6ZToxLFxuICAgICAgbWluRmlsZVNpemVFcnJvckNhbGxiYWNrOmZ1bmN0aW9uKGZpbGUsIGVycm9yQ291bnQpIHtcbiAgICAgICAgYWxlcnQoZmlsZS5maWxlTmFtZXx8ZmlsZS5uYW1lICsnIGlzIHRvbyBzbWFsbCwgcGxlYXNlIHVwbG9hZCBmaWxlcyBsYXJnZXIgdGhhbiAnICsgJGguZm9ybWF0U2l6ZSgkLmdldE9wdCgnbWluRmlsZVNpemUnKSkgKyAnLicpO1xuICAgICAgfSxcbiAgICAgIG1heEZpbGVTaXplOnVuZGVmaW5lZCxcbiAgICAgIG1heEZpbGVTaXplRXJyb3JDYWxsYmFjazpmdW5jdGlvbihmaWxlLCBlcnJvckNvdW50KSB7XG4gICAgICAgIGFsZXJ0KGZpbGUuZmlsZU5hbWV8fGZpbGUubmFtZSArJyBpcyB0b28gbGFyZ2UsIHBsZWFzZSB1cGxvYWQgZmlsZXMgbGVzcyB0aGFuICcgKyAkaC5mb3JtYXRTaXplKCQuZ2V0T3B0KCdtYXhGaWxlU2l6ZScpKSArICcuJyk7XG4gICAgICB9LFxuICAgICAgZmlsZVR5cGU6IFtdLFxuICAgICAgZmlsZVR5cGVFcnJvckNhbGxiYWNrOiBmdW5jdGlvbihmaWxlLCBlcnJvckNvdW50KSB7XG4gICAgICAgIGFsZXJ0KGZpbGUuZmlsZU5hbWV8fGZpbGUubmFtZSArJyBoYXMgdHlwZSBub3QgYWxsb3dlZCwgcGxlYXNlIHVwbG9hZCBmaWxlcyBvZiB0eXBlICcgKyAkLmdldE9wdCgnZmlsZVR5cGUnKSArICcuJyk7XG4gICAgICB9XG4gICAgfTtcbiAgICAkLm9wdHMgPSBvcHRzfHx7fTtcbiAgICAkLmdldE9wdCA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgIHZhciAkb3B0ID0gdGhpcztcbiAgICAgIC8vIEdldCBtdWx0aXBsZSBvcHRpb24gaWYgcGFzc2VkIGFuIGFycmF5XG4gICAgICBpZihvIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgJGguZWFjaChvLCBmdW5jdGlvbihvcHRpb24pe1xuICAgICAgICAgIG9wdGlvbnNbb3B0aW9uXSA9ICRvcHQuZ2V0T3B0KG9wdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgIH1cbiAgICAgIC8vIE90aGVyd2lzZSwganVzdCByZXR1cm4gYSBzaW1wbGUgb3B0aW9uXG4gICAgICBpZiAoJG9wdCBpbnN0YW5jZW9mIFJlc3VtYWJsZUNodW5rKSB7XG4gICAgICAgIGlmICh0eXBlb2YgJG9wdC5vcHRzW29dICE9PSAndW5kZWZpbmVkJykgeyByZXR1cm4gJG9wdC5vcHRzW29dOyB9XG4gICAgICAgIGVsc2UgeyAkb3B0ID0gJG9wdC5maWxlT2JqOyB9XG4gICAgICB9XG4gICAgICBpZiAoJG9wdCBpbnN0YW5jZW9mIFJlc3VtYWJsZUZpbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAkb3B0Lm9wdHNbb10gIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiAkb3B0Lm9wdHNbb107IH1cbiAgICAgICAgZWxzZSB7ICRvcHQgPSAkb3B0LnJlc3VtYWJsZU9iajsgfVxuICAgICAgfVxuICAgICAgaWYgKCRvcHQgaW5zdGFuY2VvZiBSZXN1bWFibGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAkb3B0Lm9wdHNbb10gIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiAkb3B0Lm9wdHNbb107IH1cbiAgICAgICAgZWxzZSB7IHJldHVybiAkb3B0LmRlZmF1bHRzW29dOyB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIEVWRU5UU1xuICAgIC8vIGNhdGNoQWxsKGV2ZW50LCAuLi4pXG4gICAgLy8gZmlsZVN1Y2Nlc3MoZmlsZSksIGZpbGVQcm9ncmVzcyhmaWxlKSwgZmlsZUFkZGVkKGZpbGUsIGV2ZW50KSwgZmlsZXNBZGRlZChmaWxlcywgZmlsZXNTa2lwcGVkKSwgZmlsZVJldHJ5KGZpbGUpLFxuICAgIC8vIGZpbGVFcnJvcihmaWxlLCBtZXNzYWdlKSwgY29tcGxldGUoKSwgcHJvZ3Jlc3MoKSwgZXJyb3IobWVzc2FnZSwgZmlsZSksIHBhdXNlKClcbiAgICAkLmV2ZW50cyA9IFtdO1xuICAgICQub24gPSBmdW5jdGlvbihldmVudCxjYWxsYmFjayl7XG4gICAgICAkLmV2ZW50cy5wdXNoKGV2ZW50LnRvTG93ZXJDYXNlKCksIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgICQuZmlyZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAvLyBgYXJndW1lbnRzYCBpcyBhbiBvYmplY3QsIG5vdCBhcnJheSwgaW4gRkYsIHNvOlxuICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgIGZvciAodmFyIGk9MDsgaTxhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgICAgLy8gRmluZCBldmVudCBsaXN0ZW5lcnMsIGFuZCBzdXBwb3J0IHBzZXVkby1ldmVudCBgY2F0Y2hBbGxgXG4gICAgICB2YXIgZXZlbnQgPSBhcmdzWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICBmb3IgKHZhciBpPTA7IGk8PSQuZXZlbnRzLmxlbmd0aDsgaSs9Mikge1xuICAgICAgICBpZigkLmV2ZW50c1tpXT09ZXZlbnQpICQuZXZlbnRzW2krMV0uYXBwbHkoJCxhcmdzLnNsaWNlKDEpKTtcbiAgICAgICAgaWYoJC5ldmVudHNbaV09PSdjYXRjaGFsbCcpICQuZXZlbnRzW2krMV0uYXBwbHkobnVsbCxhcmdzKTtcbiAgICAgIH1cbiAgICAgIGlmKGV2ZW50PT0nZmlsZWVycm9yJykgJC5maXJlKCdlcnJvcicsIGFyZ3NbMl0sIGFyZ3NbMV0pO1xuICAgICAgaWYoZXZlbnQ9PSdmaWxlcHJvZ3Jlc3MnKSAkLmZpcmUoJ3Byb2dyZXNzJyk7XG4gICAgfTtcblxuXG4gICAgLy8gSU5URVJOQUwgSEVMUEVSIE1FVEhPRFMgKGhhbmR5LCBidXQgdWx0aW1hdGVseSBub3QgcGFydCBvZiB1cGxvYWRpbmcpXG4gICAgdmFyICRoID0ge1xuICAgICAgc3RvcEV2ZW50OiBmdW5jdGlvbihlKXtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSxcbiAgICAgIGVhY2g6IGZ1bmN0aW9uKG8sY2FsbGJhY2spe1xuICAgICAgICBpZih0eXBlb2Yoby5sZW5ndGgpIT09J3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8by5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gQXJyYXkgb3IgRmlsZUxpc3RcbiAgICAgICAgICAgIGlmKGNhbGxiYWNrKG9baV0pPT09ZmFsc2UpIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChpIGluIG8pIHtcbiAgICAgICAgICAgIC8vIE9iamVjdFxuICAgICAgICAgICAgaWYoY2FsbGJhY2soaSxvW2ldKT09PWZhbHNlKSByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ2VuZXJhdGVVbmlxdWVJZGVudGlmaWVyOmZ1bmN0aW9uKGZpbGUsIGV2ZW50KXtcbiAgICAgICAgdmFyIGN1c3RvbSA9ICQuZ2V0T3B0KCdnZW5lcmF0ZVVuaXF1ZUlkZW50aWZpZXInKTtcbiAgICAgICAgaWYodHlwZW9mIGN1c3RvbSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBjdXN0b20oZmlsZSwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWxhdGl2ZVBhdGggPSBmaWxlLndlYmtpdFJlbGF0aXZlUGF0aHx8ZmlsZS5maWxlTmFtZXx8ZmlsZS5uYW1lOyAvLyBTb21lIGNvbmZ1c2lvbiBpbiBkaWZmZXJlbnQgdmVyc2lvbnMgb2YgRmlyZWZveFxuICAgICAgICB2YXIgc2l6ZSA9IGZpbGUuc2l6ZTtcbiAgICAgICAgcmV0dXJuKHNpemUgKyAnLScgKyByZWxhdGl2ZVBhdGgucmVwbGFjZSgvW14wLTlhLXpBLVpfLV0vaW1nLCAnJykpO1xuICAgICAgfSxcbiAgICAgIGNvbnRhaW5zOmZ1bmN0aW9uKGFycmF5LHRlc3QpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgICAgICRoLmVhY2goYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlID09IHRlc3QpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIGZvcm1hdFNpemU6ZnVuY3Rpb24oc2l6ZSl7XG4gICAgICAgIGlmKHNpemU8MTAyNCkge1xuICAgICAgICAgIHJldHVybiBzaXplICsgJyBieXRlcyc7XG4gICAgICAgIH0gZWxzZSBpZihzaXplPDEwMjQqMTAyNCkge1xuICAgICAgICAgIHJldHVybiAoc2l6ZS8xMDI0LjApLnRvRml4ZWQoMCkgKyAnIEtCJztcbiAgICAgICAgfSBlbHNlIGlmKHNpemU8MTAyNCoxMDI0KjEwMjQpIHtcbiAgICAgICAgICByZXR1cm4gKHNpemUvMTAyNC4wLzEwMjQuMCkudG9GaXhlZCgxKSArICcgTUInO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAoc2l6ZS8xMDI0LjAvMTAyNC4wLzEwMjQuMCkudG9GaXhlZCgxKSArICcgR0InO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ2V0VGFyZ2V0OmZ1bmN0aW9uKHJlcXVlc3QsIHBhcmFtcyl7XG4gICAgICAgIHZhciB0YXJnZXQgPSAkLmdldE9wdCgndGFyZ2V0Jyk7XG5cbiAgICAgICAgaWYgKHJlcXVlc3QgPT09ICd0ZXN0JyAmJiAkLmdldE9wdCgndGVzdFRhcmdldCcpKSB7XG4gICAgICAgICAgdGFyZ2V0ID0gJC5nZXRPcHQoJ3Rlc3RUYXJnZXQnKSA9PT0gJy8nID8gJC5nZXRPcHQoJ3RhcmdldCcpIDogJC5nZXRPcHQoJ3Rlc3RUYXJnZXQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIHRhcmdldChwYXJhbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlcGFyYXRvciA9IHRhcmdldC5pbmRleE9mKCc/JykgPCAwID8gJz8nIDogJyYnO1xuICAgICAgICB2YXIgam9pbmVkUGFyYW1zID0gcGFyYW1zLmpvaW4oJyYnKTtcblxuICAgICAgICByZXR1cm4gdGFyZ2V0ICsgc2VwYXJhdG9yICsgam9pbmVkUGFyYW1zO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgb25Ecm9wID0gZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgJGguc3RvcEV2ZW50KGV2ZW50KTtcblxuICAgICAgLy9oYW5kbGUgZHJvcHBlZCB0aGluZ3MgYXMgaXRlbXMgaWYgd2UgY2FuICh0aGlzIGxldHMgdXMgZGVhbCB3aXRoIGZvbGRlcnMgbmljZXIgaW4gc29tZSBjYXNlcylcbiAgICAgIGlmIChldmVudC5kYXRhVHJhbnNmZXIgJiYgZXZlbnQuZGF0YVRyYW5zZmVyLml0ZW1zKSB7XG4gICAgICAgIGxvYWRGaWxlcyhldmVudC5kYXRhVHJhbnNmZXIuaXRlbXMsIGV2ZW50KTtcbiAgICAgIH1cbiAgICAgIC8vZWxzZSBoYW5kbGUgdGhlbSBhcyBmaWxlc1xuICAgICAgZWxzZSBpZiAoZXZlbnQuZGF0YVRyYW5zZmVyICYmIGV2ZW50LmRhdGFUcmFuc2Zlci5maWxlcykge1xuICAgICAgICBsb2FkRmlsZXMoZXZlbnQuZGF0YVRyYW5zZmVyLmZpbGVzLCBldmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcHJldmVudERlZmF1bHQgPSBmdW5jdGlvbihlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHByb2Nlc3NlcyBhIHNpbmdsZSB1cGxvYWQgaXRlbSAoZmlsZSBvciBkaXJlY3RvcnkpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gaXRlbSB0byB1cGxvYWQsIG1heSBiZSBmaWxlIG9yIGRpcmVjdG9yeSBlbnRyeVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIGN1cnJlbnQgZmlsZSBwYXRoXG4gICAgICogQHBhcmFtIHtGaWxlW119IGl0ZW1zIGxpc3Qgb2YgZmlsZXMgdG8gYXBwZW5kIG5ldyBpdGVtcyB0b1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIGNhbGxiYWNrIGludm9rZWQgd2hlbiBpdGVtIGlzIHByb2Nlc3NlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb2Nlc3NJdGVtKGl0ZW0sIHBhdGgsIGl0ZW1zLCBjYikge1xuICAgICAgdmFyIGVudHJ5O1xuICAgICAgaWYoaXRlbS5pc0ZpbGUpe1xuICAgICAgICAvLyBmaWxlIHByb3ZpZGVkXG4gICAgICAgIHJldHVybiBpdGVtLmZpbGUoZnVuY3Rpb24oZmlsZSl7XG4gICAgICAgICAgZmlsZS5yZWxhdGl2ZVBhdGggPSBwYXRoICsgZmlsZS5uYW1lO1xuICAgICAgICAgIGl0ZW1zLnB1c2goZmlsZSk7XG4gICAgICAgICAgY2IoKTtcbiAgICAgICAgfSk7XG4gICAgICB9ZWxzZSBpZihpdGVtLmlzRGlyZWN0b3J5KXtcbiAgICAgICAgLy8gaXRlbSBpcyBhbHJlYWR5IGEgZGlyZWN0b3J5IGVudHJ5LCBqdXN0IGFzc2lnblxuICAgICAgICBlbnRyeSA9IGl0ZW07XG4gICAgICB9ZWxzZSBpZihpdGVtIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgfVxuICAgICAgaWYoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGl0ZW0ud2Via2l0R2V0QXNFbnRyeSl7XG4gICAgICAgIC8vIGdldCBlbnRyeSBmcm9tIGZpbGUgb2JqZWN0XG4gICAgICAgIGVudHJ5ID0gaXRlbS53ZWJraXRHZXRBc0VudHJ5KCk7XG4gICAgICB9XG4gICAgICBpZihlbnRyeSAmJiBlbnRyeS5pc0RpcmVjdG9yeSl7XG4gICAgICAgIC8vIGRpcmVjdG9yeSBwcm92aWRlZCwgcHJvY2VzcyBpdFxuICAgICAgICByZXR1cm4gcHJvY2Vzc0RpcmVjdG9yeShlbnRyeSwgcGF0aCArIGVudHJ5Lm5hbWUgKyAnLycsIGl0ZW1zLCBjYik7XG4gICAgICB9XG4gICAgICBpZignZnVuY3Rpb24nID09PSB0eXBlb2YgaXRlbS5nZXRBc0ZpbGUpe1xuICAgICAgICAvLyBpdGVtIHJlcHJlc2VudHMgYSBGaWxlIG9iamVjdCwgY29udmVydCBpdFxuICAgICAgICBpdGVtID0gaXRlbS5nZXRBc0ZpbGUoKTtcbiAgICAgICAgaWYoaXRlbSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgICBpdGVtLnJlbGF0aXZlUGF0aCA9IHBhdGggKyBpdGVtLm5hbWU7XG4gICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2IoKTsgLy8gaW5kaWNhdGUgcHJvY2Vzc2luZyBpcyBkb25lXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBjcHMtc3R5bGUgbGlzdCBpdGVyYXRpb24uXG4gICAgICogaW52b2tlcyBhbGwgZnVuY3Rpb25zIGluIGxpc3QgYW5kIHdhaXRzIGZvciB0aGVpciBjYWxsYmFjayB0byBiZVxuICAgICAqIHRyaWdnZXJlZC5cbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbltdfSAgIGl0ZW1zIGxpc3Qgb2YgZnVuY3Rpb25zIGV4cGVjdGluZyBjYWxsYmFjayBwYXJhbWV0ZXJcbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2IgICAgY2FsbGJhY2sgdG8gdHJpZ2dlciBhZnRlciB0aGUgbGFzdCBjYWxsYmFjayBoYXMgYmVlbiBpbnZva2VkXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0NhbGxiYWNrcyhpdGVtcywgY2Ipe1xuICAgICAgaWYoIWl0ZW1zIHx8IGl0ZW1zLmxlbmd0aCA9PT0gMCl7XG4gICAgICAgIC8vIGVtcHR5IG9yIG5vIGxpc3QsIGludm9rZSBjYWxsYmFja1xuICAgICAgICByZXR1cm4gY2IoKTtcbiAgICAgIH1cbiAgICAgIC8vIGludm9rZSBjdXJyZW50IGZ1bmN0aW9uLCBwYXNzIHRoZSBuZXh0IHBhcnQgYXMgY29udGludWF0aW9uXG4gICAgICBpdGVtc1swXShmdW5jdGlvbigpe1xuICAgICAgICBwcm9jZXNzQ2FsbGJhY2tzKGl0ZW1zLnNsaWNlKDEpLCBjYik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZWN1cnNpdmVseSB0cmF2ZXJzZSBkaXJlY3RvcnkgYW5kIGNvbGxlY3QgZmlsZXMgdG8gdXBsb2FkXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSAgIGRpcmVjdG9yeSBkaXJlY3RvcnkgdG8gcHJvY2Vzc1xuICAgICAqIEBwYXJhbSAge3N0cmluZ30gICBwYXRoICAgICAgY3VycmVudCBwYXRoXG4gICAgICogQHBhcmFtICB7RmlsZVtdfSAgIGl0ZW1zICAgICB0YXJnZXQgbGlzdCBvZiBpdGVtc1xuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYiAgICAgICAgY2FsbGJhY2sgaW52b2tlZCBhZnRlciB0cmF2ZXJzaW5nIGRpcmVjdG9yeVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb2Nlc3NEaXJlY3RvcnkgKGRpcmVjdG9yeSwgcGF0aCwgaXRlbXMsIGNiKSB7XG4gICAgICB2YXIgZGlyUmVhZGVyID0gZGlyZWN0b3J5LmNyZWF0ZVJlYWRlcigpO1xuICAgICAgZGlyUmVhZGVyLnJlYWRFbnRyaWVzKGZ1bmN0aW9uKGVudHJpZXMpe1xuICAgICAgICBpZighZW50cmllcy5sZW5ndGgpe1xuICAgICAgICAgIC8vIGVtcHR5IGRpcmVjdG9yeSwgc2tpcFxuICAgICAgICAgIHJldHVybiBjYigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHByb2Nlc3MgYWxsIGNvbnZlcnNpb24gY2FsbGJhY2tzLCBmaW5hbGx5IGludm9rZSBvd24gb25lXG4gICAgICAgIHByb2Nlc3NDYWxsYmFja3MoXG4gICAgICAgICAgZW50cmllcy5tYXAoZnVuY3Rpb24oZW50cnkpe1xuICAgICAgICAgICAgLy8gYmluZCBhbGwgcHJvcGVydGllcyBleGNlcHQgZm9yIGNhbGxiYWNrXG4gICAgICAgICAgICByZXR1cm4gcHJvY2Vzc0l0ZW0uYmluZChudWxsLCBlbnRyeSwgcGF0aCwgaXRlbXMpO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGNiXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwcm9jZXNzIGl0ZW1zIHRvIGV4dHJhY3QgZmlsZXMgdG8gYmUgdXBsb2FkZWRcbiAgICAgKiBAcGFyYW0gIHtGaWxlW119IGl0ZW1zIGl0ZW1zIHRvIHByb2Nlc3NcbiAgICAgKiBAcGFyYW0gIHtFdmVudH0gZXZlbnQgZXZlbnQgdGhhdCBsZWQgdG8gdXBsb2FkXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9hZEZpbGVzKGl0ZW1zLCBldmVudCkge1xuICAgICAgaWYoIWl0ZW1zLmxlbmd0aCl7XG4gICAgICAgIHJldHVybjsgLy8gbm90aGluZyB0byBkb1xuICAgICAgfVxuICAgICAgJC5maXJlKCdiZWZvcmVBZGQnKTtcbiAgICAgIHZhciBmaWxlcyA9IFtdO1xuICAgICAgcHJvY2Vzc0NhbGxiYWNrcyhcbiAgICAgICAgICBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoaXRlbXMsIGZ1bmN0aW9uKGl0ZW0pe1xuICAgICAgICAgICAgLy8gYmluZCBhbGwgcHJvcGVydGllcyBleGNlcHQgZm9yIGNhbGxiYWNrXG4gICAgICAgICAgICByZXR1cm4gcHJvY2Vzc0l0ZW0uYmluZChudWxsLCBpdGVtLCBcIlwiLCBmaWxlcyk7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGlmKGZpbGVzLmxlbmd0aCl7XG4gICAgICAgICAgICAgIC8vIGF0IGxlYXN0IG9uZSBmaWxlIGZvdW5kXG4gICAgICAgICAgICAgIGFwcGVuZEZpbGVzRnJvbUZpbGVMaXN0KGZpbGVzLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIGFwcGVuZEZpbGVzRnJvbUZpbGVMaXN0ID0gZnVuY3Rpb24oZmlsZUxpc3QsIGV2ZW50KXtcbiAgICAgIC8vIGNoZWNrIGZvciB1cGxvYWRpbmcgdG9vIG1hbnkgZmlsZXNcbiAgICAgIHZhciBlcnJvckNvdW50ID0gMDtcbiAgICAgIHZhciBvID0gJC5nZXRPcHQoWydtYXhGaWxlcycsICdtaW5GaWxlU2l6ZScsICdtYXhGaWxlU2l6ZScsICdtYXhGaWxlc0Vycm9yQ2FsbGJhY2snLCAnbWluRmlsZVNpemVFcnJvckNhbGxiYWNrJywgJ21heEZpbGVTaXplRXJyb3JDYWxsYmFjaycsICdmaWxlVHlwZScsICdmaWxlVHlwZUVycm9yQ2FsbGJhY2snXSk7XG4gICAgICBpZiAodHlwZW9mKG8ubWF4RmlsZXMpIT09J3VuZGVmaW5lZCcgJiYgby5tYXhGaWxlczwoZmlsZUxpc3QubGVuZ3RoKyQuZmlsZXMubGVuZ3RoKSkge1xuICAgICAgICAvLyBpZiBzaW5nbGUtZmlsZSB1cGxvYWQsIGZpbGUgaXMgYWxyZWFkeSBhZGRlZCwgYW5kIHRyeWluZyB0byBhZGQgMSBuZXcgZmlsZSwgc2ltcGx5IHJlcGxhY2UgdGhlIGFscmVhZHktYWRkZWQgZmlsZVxuICAgICAgICBpZiAoby5tYXhGaWxlcz09PTEgJiYgJC5maWxlcy5sZW5ndGg9PT0xICYmIGZpbGVMaXN0Lmxlbmd0aD09PTEpIHtcbiAgICAgICAgICAkLnJlbW92ZUZpbGUoJC5maWxlc1swXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgby5tYXhGaWxlc0Vycm9yQ2FsbGJhY2soZmlsZUxpc3QsIGVycm9yQ291bnQrKyk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZmlsZXMgPSBbXSwgZmlsZXNTa2lwcGVkID0gW10sIHJlbWFpbmluZyA9IGZpbGVMaXN0Lmxlbmd0aDtcbiAgICAgIHZhciBkZWNyZWFzZVJlYW1pbmluZyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKCEtLXJlbWFpbmluZyl7XG4gICAgICAgICAgLy8gYWxsIGZpbGVzIHByb2Nlc3NlZCwgdHJpZ2dlciBldmVudFxuICAgICAgICAgIGlmKCFmaWxlcy5sZW5ndGggJiYgIWZpbGVzU2tpcHBlZC5sZW5ndGgpe1xuICAgICAgICAgICAgLy8gbm8gc3VjY2VlZGVkIGZpbGVzLCBqdXN0IHNraXBcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICQuZmlyZSgnZmlsZXNBZGRlZCcsIGZpbGVzLCBmaWxlc1NraXBwZWQpO1xuICAgICAgICAgIH0sMCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICAkaC5lYWNoKGZpbGVMaXN0LCBmdW5jdGlvbihmaWxlKXtcbiAgICAgICAgdmFyIGZpbGVOYW1lID0gZmlsZS5uYW1lO1xuICAgICAgICBpZihvLmZpbGVUeXBlLmxlbmd0aCA+IDApe1xuICAgICAgICAgIHZhciBmaWxlVHlwZUZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgZm9yKHZhciBpbmRleCBpbiBvLmZpbGVUeXBlKXtcbiAgICAgICAgICAgIHZhciBleHRlbnNpb24gPSAnLicgKyBvLmZpbGVUeXBlW2luZGV4XTtcblx0XHRcdGlmKGZpbGVOYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihleHRlbnNpb24udG9Mb3dlckNhc2UoKSwgZmlsZU5hbWUubGVuZ3RoIC0gZXh0ZW5zaW9uLmxlbmd0aCkgIT09IC0xKXtcbiAgICAgICAgICAgICAgZmlsZVR5cGVGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWZpbGVUeXBlRm91bmQpIHtcbiAgICAgICAgICAgIG8uZmlsZVR5cGVFcnJvckNhbGxiYWNrKGZpbGUsIGVycm9yQ291bnQrKyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZihvLm1pbkZpbGVTaXplKSE9PSd1bmRlZmluZWQnICYmIGZpbGUuc2l6ZTxvLm1pbkZpbGVTaXplKSB7XG4gICAgICAgICAgby5taW5GaWxlU2l6ZUVycm9yQ2FsbGJhY2soZmlsZSwgZXJyb3JDb3VudCsrKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZihvLm1heEZpbGVTaXplKSE9PSd1bmRlZmluZWQnICYmIGZpbGUuc2l6ZT5vLm1heEZpbGVTaXplKSB7XG4gICAgICAgICAgby5tYXhGaWxlU2l6ZUVycm9yQ2FsbGJhY2soZmlsZSwgZXJyb3JDb3VudCsrKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhZGRGaWxlKHVuaXF1ZUlkZW50aWZpZXIpe1xuICAgICAgICAgIGlmICghJC5nZXRGcm9tVW5pcXVlSWRlbnRpZmllcih1bmlxdWVJZGVudGlmaWVyKSkgeyhmdW5jdGlvbigpe1xuICAgICAgICAgICAgZmlsZS51bmlxdWVJZGVudGlmaWVyID0gdW5pcXVlSWRlbnRpZmllcjtcbiAgICAgICAgICAgIHZhciBmID0gbmV3IFJlc3VtYWJsZUZpbGUoJCwgZmlsZSwgdW5pcXVlSWRlbnRpZmllcik7XG4gICAgICAgICAgICAkLmZpbGVzLnB1c2goZik7XG4gICAgICAgICAgICBmaWxlcy5wdXNoKGYpO1xuICAgICAgICAgICAgZi5jb250YWluZXIgPSAodHlwZW9mIGV2ZW50ICE9ICd1bmRlZmluZWQnID8gZXZlbnQuc3JjRWxlbWVudCA6IG51bGwpO1xuICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgJC5maXJlKCdmaWxlQWRkZWQnLCBmLCBldmVudClcbiAgICAgICAgICAgIH0sMCk7XG4gICAgICAgICAgfSkoKX0gZWxzZSB7XG4gICAgICAgICAgICBmaWxlc1NraXBwZWQucHVzaChmaWxlKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGRlY3JlYXNlUmVhbWluaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGlyZWN0b3JpZXMgaGF2ZSBzaXplID09IDBcbiAgICAgICAgdmFyIHVuaXF1ZUlkZW50aWZpZXIgPSAkaC5nZW5lcmF0ZVVuaXF1ZUlkZW50aWZpZXIoZmlsZSwgZXZlbnQpO1xuICAgICAgICBpZih1bmlxdWVJZGVudGlmaWVyICYmIHR5cGVvZiB1bmlxdWVJZGVudGlmaWVyLnRoZW4gPT09ICdmdW5jdGlvbicpe1xuICAgICAgICAgIC8vIFByb21pc2Ugb3IgUHJvbWlzZS1saWtlIG9iamVjdCBwcm92aWRlZCBhcyB1bmlxdWUgaWRlbnRpZmllclxuICAgICAgICAgIHVuaXF1ZUlkZW50aWZpZXJcbiAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgIGZ1bmN0aW9uKHVuaXF1ZUlkZW50aWZpZXIpe1xuICAgICAgICAgICAgICAvLyB1bmlxdWUgaWRlbnRpZmllciBnZW5lcmF0aW9uIHN1Y2NlZWRlZFxuICAgICAgICAgICAgICBhZGRGaWxlKHVuaXF1ZUlkZW50aWZpZXIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgLy8gdW5pcXVlIGlkZW50aWZpZXIgZ2VuZXJhdGlvbiBmYWlsZWRcbiAgICAgICAgICAgICAgLy8gc2tpcCBmdXJ0aGVyIHByb2Nlc3NpbmcsIG9ubHkgZGVjcmVhc2UgZmlsZSBjb3VudFxuICAgICAgICAgICAgICBkZWNyZWFzZVJlYW1pbmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIC8vIG5vbi1Qcm9taXNlIHByb3ZpZGVkIGFzIHVuaXF1ZSBpZGVudGlmaWVyLCBwcm9jZXNzIHN5bmNocm9ub3VzbHlcbiAgICAgICAgICBhZGRGaWxlKHVuaXF1ZUlkZW50aWZpZXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gSU5URVJOQUwgT0JKRUNUIFRZUEVTXG4gICAgZnVuY3Rpb24gUmVzdW1hYmxlRmlsZShyZXN1bWFibGVPYmosIGZpbGUsIHVuaXF1ZUlkZW50aWZpZXIpe1xuICAgICAgdmFyICQgPSB0aGlzO1xuICAgICAgJC5vcHRzID0ge307XG4gICAgICAkLmdldE9wdCA9IHJlc3VtYWJsZU9iai5nZXRPcHQ7XG4gICAgICAkLl9wcmV2UHJvZ3Jlc3MgPSAwO1xuICAgICAgJC5yZXN1bWFibGVPYmogPSByZXN1bWFibGVPYmo7XG4gICAgICAkLmZpbGUgPSBmaWxlO1xuICAgICAgJC5maWxlTmFtZSA9IGZpbGUuZmlsZU5hbWV8fGZpbGUubmFtZTsgLy8gU29tZSBjb25mdXNpb24gaW4gZGlmZmVyZW50IHZlcnNpb25zIG9mIEZpcmVmb3hcbiAgICAgICQuc2l6ZSA9IGZpbGUuc2l6ZTtcbiAgICAgICQucmVsYXRpdmVQYXRoID0gZmlsZS5yZWxhdGl2ZVBhdGggfHwgZmlsZS53ZWJraXRSZWxhdGl2ZVBhdGggfHwgJC5maWxlTmFtZTtcbiAgICAgICQudW5pcXVlSWRlbnRpZmllciA9IHVuaXF1ZUlkZW50aWZpZXI7XG4gICAgICAkLl9wYXVzZSA9IGZhbHNlO1xuICAgICAgJC5jb250YWluZXIgPSAnJztcbiAgICAgIHZhciBfZXJyb3IgPSB1bmlxdWVJZGVudGlmaWVyICE9PSB1bmRlZmluZWQ7XG5cbiAgICAgIC8vIENhbGxiYWNrIHdoZW4gc29tZXRoaW5nIGhhcHBlbnMgd2l0aGluIHRoZSBjaHVua1xuICAgICAgdmFyIGNodW5rRXZlbnQgPSBmdW5jdGlvbihldmVudCwgbWVzc2FnZSl7XG4gICAgICAgIC8vIGV2ZW50IGNhbiBiZSAncHJvZ3Jlc3MnLCAnc3VjY2VzcycsICdlcnJvcicgb3IgJ3JldHJ5J1xuICAgICAgICBzd2l0Y2goZXZlbnQpe1xuICAgICAgICBjYXNlICdwcm9ncmVzcyc6XG4gICAgICAgICAgJC5yZXN1bWFibGVPYmouZmlyZSgnZmlsZVByb2dyZXNzJywgJCwgbWVzc2FnZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAkLmFib3J0KCk7XG4gICAgICAgICAgX2Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAkLmNodW5rcyA9IFtdO1xuICAgICAgICAgICQucmVzdW1hYmxlT2JqLmZpcmUoJ2ZpbGVFcnJvcicsICQsIG1lc3NhZ2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzdWNjZXNzJzpcbiAgICAgICAgICBpZihfZXJyb3IpIHJldHVybjtcbiAgICAgICAgICAkLnJlc3VtYWJsZU9iai5maXJlKCdmaWxlUHJvZ3Jlc3MnLCAkKTsgLy8gaXQncyBhdCBsZWFzdCBwcm9ncmVzc1xuICAgICAgICAgIGlmKCQuaXNDb21wbGV0ZSgpKSB7XG4gICAgICAgICAgICAkLnJlc3VtYWJsZU9iai5maXJlKCdmaWxlU3VjY2VzcycsICQsIG1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmV0cnknOlxuICAgICAgICAgICQucmVzdW1hYmxlT2JqLmZpcmUoJ2ZpbGVSZXRyeScsICQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBNYWluIGNvZGUgdG8gc2V0IHVwIGEgZmlsZSBvYmplY3Qgd2l0aCBjaHVua3MsXG4gICAgICAvLyBwYWNrYWdlZCB0byBiZSBhYmxlIHRvIGhhbmRsZSByZXRyaWVzIGlmIG5lZWRlZC5cbiAgICAgICQuY2h1bmtzID0gW107XG4gICAgICAkLmFib3J0ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gU3RvcCBjdXJyZW50IHVwbG9hZHNcbiAgICAgICAgdmFyIGFib3J0Q291bnQgPSAwO1xuICAgICAgICAkaC5lYWNoKCQuY2h1bmtzLCBmdW5jdGlvbihjKXtcbiAgICAgICAgICBpZihjLnN0YXR1cygpPT0ndXBsb2FkaW5nJykge1xuICAgICAgICAgICAgYy5hYm9ydCgpO1xuICAgICAgICAgICAgYWJvcnRDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmKGFib3J0Q291bnQ+MCkgJC5yZXN1bWFibGVPYmouZmlyZSgnZmlsZVByb2dyZXNzJywgJCk7XG4gICAgICB9O1xuICAgICAgJC5jYW5jZWwgPSBmdW5jdGlvbigpe1xuICAgICAgICAvLyBSZXNldCB0aGlzIGZpbGUgdG8gYmUgdm9pZFxuICAgICAgICB2YXIgX2NodW5rcyA9ICQuY2h1bmtzO1xuICAgICAgICAkLmNodW5rcyA9IFtdO1xuICAgICAgICAvLyBTdG9wIGN1cnJlbnQgdXBsb2Fkc1xuICAgICAgICAkaC5lYWNoKF9jaHVua3MsIGZ1bmN0aW9uKGMpe1xuICAgICAgICAgIGlmKGMuc3RhdHVzKCk9PSd1cGxvYWRpbmcnKSAge1xuICAgICAgICAgICAgYy5hYm9ydCgpO1xuICAgICAgICAgICAgJC5yZXN1bWFibGVPYmoudXBsb2FkTmV4dENodW5rKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgJC5yZXN1bWFibGVPYmoucmVtb3ZlRmlsZSgkKTtcbiAgICAgICAgJC5yZXN1bWFibGVPYmouZmlyZSgnZmlsZVByb2dyZXNzJywgJCk7XG4gICAgICB9O1xuICAgICAgJC5yZXRyeSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICQuYm9vdHN0cmFwKCk7XG4gICAgICAgIHZhciBmaXJlZFJldHJ5ID0gZmFsc2U7XG4gICAgICAgICQucmVzdW1hYmxlT2JqLm9uKCdjaHVua2luZ0NvbXBsZXRlJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICBpZighZmlyZWRSZXRyeSkgJC5yZXN1bWFibGVPYmoudXBsb2FkKCk7XG4gICAgICAgICAgZmlyZWRSZXRyeSA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgICQuYm9vdHN0cmFwID0gZnVuY3Rpb24oKXtcbiAgICAgICAgJC5hYm9ydCgpO1xuICAgICAgICBfZXJyb3IgPSBmYWxzZTtcbiAgICAgICAgLy8gUmVidWlsZCBzdGFjayBvZiBjaHVua3MgZnJvbSBmaWxlXG4gICAgICAgICQuY2h1bmtzID0gW107XG4gICAgICAgICQuX3ByZXZQcm9ncmVzcyA9IDA7XG4gICAgICAgIHZhciByb3VuZCA9ICQuZ2V0T3B0KCdmb3JjZUNodW5rU2l6ZScpID8gTWF0aC5jZWlsIDogTWF0aC5mbG9vcjtcbiAgICAgICAgdmFyIG1heE9mZnNldCA9IE1hdGgubWF4KHJvdW5kKCQuZmlsZS5zaXplLyQuZ2V0T3B0KCdjaHVua1NpemUnKSksMSk7XG4gICAgICAgIGZvciAodmFyIG9mZnNldD0wOyBvZmZzZXQ8bWF4T2Zmc2V0OyBvZmZzZXQrKykgeyhmdW5jdGlvbihvZmZzZXQpe1xuICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAkLmNodW5rcy5wdXNoKG5ldyBSZXN1bWFibGVDaHVuaygkLnJlc3VtYWJsZU9iaiwgJCwgb2Zmc2V0LCBjaHVua0V2ZW50KSk7XG4gICAgICAgICAgICAgICAgJC5yZXN1bWFibGVPYmouZmlyZSgnY2h1bmtpbmdQcm9ncmVzcycsJCxvZmZzZXQvbWF4T2Zmc2V0KTtcbiAgICAgICAgICAgIH0sMCk7XG4gICAgICAgIH0pKG9mZnNldCl9XG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAkLnJlc3VtYWJsZU9iai5maXJlKCdjaHVua2luZ0NvbXBsZXRlJywkKTtcbiAgICAgICAgfSwwKTtcbiAgICAgIH07XG4gICAgICAkLnByb2dyZXNzID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoX2Vycm9yKSByZXR1cm4oMSk7XG4gICAgICAgIC8vIFN1bSB1cCBwcm9ncmVzcyBhY3Jvc3MgZXZlcnl0aGluZ1xuICAgICAgICB2YXIgcmV0ID0gMDtcbiAgICAgICAgdmFyIGVycm9yID0gZmFsc2U7XG4gICAgICAgICRoLmVhY2goJC5jaHVua3MsIGZ1bmN0aW9uKGMpe1xuICAgICAgICAgIGlmKGMuc3RhdHVzKCk9PSdlcnJvcicpIGVycm9yID0gdHJ1ZTtcbiAgICAgICAgICByZXQgKz0gYy5wcm9ncmVzcyh0cnVlKTsgLy8gZ2V0IGNodW5rIHByb2dyZXNzIHJlbGF0aXZlIHRvIGVudGlyZSBmaWxlXG4gICAgICAgIH0pO1xuICAgICAgICByZXQgPSAoZXJyb3IgPyAxIDogKHJldD4wLjk5OTk5ID8gMSA6IHJldCkpO1xuICAgICAgICByZXQgPSBNYXRoLm1heCgkLl9wcmV2UHJvZ3Jlc3MsIHJldCk7IC8vIFdlIGRvbid0IHdhbnQgdG8gbG9zZSBwZXJjZW50YWdlcyB3aGVuIGFuIHVwbG9hZCBpcyBwYXVzZWRcbiAgICAgICAgJC5fcHJldlByb2dyZXNzID0gcmV0O1xuICAgICAgICByZXR1cm4ocmV0KTtcbiAgICAgIH07XG4gICAgICAkLmlzVXBsb2FkaW5nID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHVwbG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAkaC5lYWNoKCQuY2h1bmtzLCBmdW5jdGlvbihjaHVuayl7XG4gICAgICAgICAgaWYoY2h1bmsuc3RhdHVzKCk9PSd1cGxvYWRpbmcnKSB7XG4gICAgICAgICAgICB1cGxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuKGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4odXBsb2FkaW5nKTtcbiAgICAgIH07XG4gICAgICAkLmlzQ29tcGxldGUgPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgb3V0c3RhbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgJGguZWFjaCgkLmNodW5rcywgZnVuY3Rpb24oY2h1bmspe1xuICAgICAgICAgIHZhciBzdGF0dXMgPSBjaHVuay5zdGF0dXMoKTtcbiAgICAgICAgICBpZihzdGF0dXM9PSdwZW5kaW5nJyB8fCBzdGF0dXM9PSd1cGxvYWRpbmcnIHx8IGNodW5rLnByZXByb2Nlc3NTdGF0ZSA9PT0gMSkge1xuICAgICAgICAgICAgb3V0c3RhbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuKGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4oIW91dHN0YW5kaW5nKTtcbiAgICAgIH07XG4gICAgICAkLnBhdXNlID0gZnVuY3Rpb24ocGF1c2Upe1xuICAgICAgICAgIGlmKHR5cGVvZihwYXVzZSk9PT0ndW5kZWZpbmVkJyl7XG4gICAgICAgICAgICAgICQuX3BhdXNlID0gKCQuX3BhdXNlID8gZmFsc2UgOiB0cnVlKTtcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgJC5fcGF1c2UgPSBwYXVzZTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgJC5pc1BhdXNlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJC5fcGF1c2U7XG4gICAgICB9O1xuXG5cbiAgICAgIC8vIEJvb3RzdHJhcCBhbmQgcmV0dXJuXG4gICAgICAkLnJlc3VtYWJsZU9iai5maXJlKCdjaHVua2luZ1N0YXJ0JywgJCk7XG4gICAgICAkLmJvb3RzdHJhcCgpO1xuICAgICAgcmV0dXJuKHRoaXMpO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gUmVzdW1hYmxlQ2h1bmsocmVzdW1hYmxlT2JqLCBmaWxlT2JqLCBvZmZzZXQsIGNhbGxiYWNrKXtcbiAgICAgIHZhciAkID0gdGhpcztcbiAgICAgICQub3B0cyA9IHt9O1xuICAgICAgJC5nZXRPcHQgPSByZXN1bWFibGVPYmouZ2V0T3B0O1xuICAgICAgJC5yZXN1bWFibGVPYmogPSByZXN1bWFibGVPYmo7XG4gICAgICAkLmZpbGVPYmogPSBmaWxlT2JqO1xuICAgICAgJC5maWxlT2JqU2l6ZSA9IGZpbGVPYmouc2l6ZTtcbiAgICAgICQuZmlsZU9ialR5cGUgPSBmaWxlT2JqLmZpbGUudHlwZTtcbiAgICAgICQub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgJC5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgJC5sYXN0UHJvZ3Jlc3NDYWxsYmFjayA9IChuZXcgRGF0ZSk7XG4gICAgICAkLnRlc3RlZCA9IGZhbHNlO1xuICAgICAgJC5yZXRyaWVzID0gMDtcbiAgICAgICQucGVuZGluZ1JldHJ5ID0gZmFsc2U7XG4gICAgICAkLnByZXByb2Nlc3NTdGF0ZSA9IDA7IC8vIDAgPSB1bnByb2Nlc3NlZCwgMSA9IHByb2Nlc3NpbmcsIDIgPSBmaW5pc2hlZFxuXG4gICAgICAvLyBDb21wdXRlZCBwcm9wZXJ0aWVzXG4gICAgICB2YXIgY2h1bmtTaXplID0gJC5nZXRPcHQoJ2NodW5rU2l6ZScpO1xuICAgICAgJC5sb2FkZWQgPSAwO1xuICAgICAgJC5zdGFydEJ5dGUgPSAkLm9mZnNldCpjaHVua1NpemU7XG4gICAgICAkLmVuZEJ5dGUgPSBNYXRoLm1pbigkLmZpbGVPYmpTaXplLCAoJC5vZmZzZXQrMSkqY2h1bmtTaXplKTtcbiAgICAgIGlmICgkLmZpbGVPYmpTaXplLSQuZW5kQnl0ZSA8IGNodW5rU2l6ZSAmJiAhJC5nZXRPcHQoJ2ZvcmNlQ2h1bmtTaXplJykpIHtcbiAgICAgICAgLy8gVGhlIGxhc3QgY2h1bmsgd2lsbCBiZSBiaWdnZXIgdGhhbiB0aGUgY2h1bmsgc2l6ZSwgYnV0IGxlc3MgdGhhbiAyKmNodW5rU2l6ZVxuICAgICAgICAkLmVuZEJ5dGUgPSAkLmZpbGVPYmpTaXplO1xuICAgICAgfVxuICAgICAgJC54aHIgPSBudWxsO1xuXG4gICAgICAvLyB0ZXN0KCkgbWFrZXMgYSBHRVQgcmVxdWVzdCB3aXRob3V0IGFueSBkYXRhIHRvIHNlZSBpZiB0aGUgY2h1bmsgaGFzIGFscmVhZHkgYmVlbiB1cGxvYWRlZCBpbiBhIHByZXZpb3VzIHNlc3Npb25cbiAgICAgICQudGVzdCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vIFNldCB1cCByZXF1ZXN0IGFuZCBsaXN0ZW4gZm9yIGV2ZW50XG4gICAgICAgICQueGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgICAgdmFyIHRlc3RIYW5kbGVyID0gZnVuY3Rpb24oZSl7XG4gICAgICAgICAgJC50ZXN0ZWQgPSB0cnVlO1xuICAgICAgICAgIHZhciBzdGF0dXMgPSAkLnN0YXR1cygpO1xuICAgICAgICAgIGlmKHN0YXR1cz09J3N1Y2Nlc3MnKSB7XG4gICAgICAgICAgICAkLmNhbGxiYWNrKHN0YXR1cywgJC5tZXNzYWdlKCkpO1xuICAgICAgICAgICAgJC5yZXN1bWFibGVPYmoudXBsb2FkTmV4dENodW5rKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICQuc2VuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgJC54aHIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRlc3RIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgICQueGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGVzdEhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgJC54aHIuYWRkRXZlbnRMaXN0ZW5lcigndGltZW91dCcsIHRlc3RIYW5kbGVyLCBmYWxzZSk7XG5cbiAgICAgICAgLy8gQWRkIGRhdGEgZnJvbSB0aGUgcXVlcnkgb3B0aW9uc1xuICAgICAgICB2YXIgcGFyYW1zID0gW107XG4gICAgICAgIHZhciBwYXJhbWV0ZXJOYW1lc3BhY2UgPSAkLmdldE9wdCgncGFyYW1ldGVyTmFtZXNwYWNlJyk7XG4gICAgICAgIHZhciBjdXN0b21RdWVyeSA9ICQuZ2V0T3B0KCdxdWVyeScpO1xuICAgICAgICBpZih0eXBlb2YgY3VzdG9tUXVlcnkgPT0gJ2Z1bmN0aW9uJykgY3VzdG9tUXVlcnkgPSBjdXN0b21RdWVyeSgkLmZpbGVPYmosICQpO1xuICAgICAgICAkaC5lYWNoKGN1c3RvbVF1ZXJ5LCBmdW5jdGlvbihrLHYpe1xuICAgICAgICAgIHBhcmFtcy5wdXNoKFtlbmNvZGVVUklDb21wb25lbnQocGFyYW1ldGVyTmFtZXNwYWNlK2spLCBlbmNvZGVVUklDb21wb25lbnQodildLmpvaW4oJz0nKSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBZGQgZXh0cmEgZGF0YSB0byBpZGVudGlmeSBjaHVua1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMuY29uY2F0KFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIC8vIGRlZmluZSBrZXkvdmFsdWUgcGFpcnMgZm9yIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICAgICAgICAgICAgWydjaHVua051bWJlclBhcmFtZXRlck5hbWUnLCAkLm9mZnNldCArIDFdLFxuICAgICAgICAgICAgWydjaHVua1NpemVQYXJhbWV0ZXJOYW1lJywgJC5nZXRPcHQoJ2NodW5rU2l6ZScpXSxcbiAgICAgICAgICAgIFsnY3VycmVudENodW5rU2l6ZVBhcmFtZXRlck5hbWUnLCAkLmVuZEJ5dGUgLSAkLnN0YXJ0Qnl0ZV0sXG4gICAgICAgICAgICBbJ3RvdGFsU2l6ZVBhcmFtZXRlck5hbWUnLCAkLmZpbGVPYmpTaXplXSxcbiAgICAgICAgICAgIFsndHlwZVBhcmFtZXRlck5hbWUnLCAkLmZpbGVPYmpUeXBlXSxcbiAgICAgICAgICAgIFsnaWRlbnRpZmllclBhcmFtZXRlck5hbWUnLCAkLmZpbGVPYmoudW5pcXVlSWRlbnRpZmllcl0sXG4gICAgICAgICAgICBbJ2ZpbGVOYW1lUGFyYW1ldGVyTmFtZScsICQuZmlsZU9iai5maWxlTmFtZV0sXG4gICAgICAgICAgICBbJ3JlbGF0aXZlUGF0aFBhcmFtZXRlck5hbWUnLCAkLmZpbGVPYmoucmVsYXRpdmVQYXRoXSxcbiAgICAgICAgICAgIFsndG90YWxDaHVua3NQYXJhbWV0ZXJOYW1lJywgJC5maWxlT2JqLmNodW5rcy5sZW5ndGhdXG4gICAgICAgICAgXS5maWx0ZXIoZnVuY3Rpb24ocGFpcil7XG4gICAgICAgICAgICAvLyBpbmNsdWRlIGl0ZW1zIHRoYXQgcmVzb2x2ZSB0byB0cnV0aHkgdmFsdWVzXG4gICAgICAgICAgICAvLyBpLmUuIGV4Y2x1ZGUgZmFsc2UsIG51bGwsIHVuZGVmaW5lZCBhbmQgZW1wdHkgc3RyaW5nc1xuICAgICAgICAgICAgcmV0dXJuICQuZ2V0T3B0KHBhaXJbMF0pO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLm1hcChmdW5jdGlvbihwYWlyKXtcbiAgICAgICAgICAgIC8vIG1hcCBlYWNoIGtleS92YWx1ZSBwYWlyIHRvIGl0cyBmaW5hbCBmb3JtXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICBwYXJhbWV0ZXJOYW1lc3BhY2UgKyAkLmdldE9wdChwYWlyWzBdKSxcbiAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0pXG4gICAgICAgICAgICBdLmpvaW4oJz0nKTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICAvLyBBcHBlbmQgdGhlIHJlbGV2YW50IGNodW5rIGFuZCBzZW5kIGl0XG4gICAgICAgICQueGhyLm9wZW4oJC5nZXRPcHQoJ3Rlc3RNZXRob2QnKSwgJGguZ2V0VGFyZ2V0KCd0ZXN0JywgcGFyYW1zKSk7XG4gICAgICAgICQueGhyLnRpbWVvdXQgPSAkLmdldE9wdCgneGhyVGltZW91dCcpO1xuICAgICAgICAkLnhoci53aXRoQ3JlZGVudGlhbHMgPSAkLmdldE9wdCgnd2l0aENyZWRlbnRpYWxzJyk7XG4gICAgICAgIC8vIEFkZCBkYXRhIGZyb20gaGVhZGVyIG9wdGlvbnNcbiAgICAgICAgdmFyIGN1c3RvbUhlYWRlcnMgPSAkLmdldE9wdCgnaGVhZGVycycpO1xuICAgICAgICBpZih0eXBlb2YgY3VzdG9tSGVhZGVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGN1c3RvbUhlYWRlcnMgPSBjdXN0b21IZWFkZXJzKCQuZmlsZU9iaiwgJCk7XG4gICAgICAgIH1cbiAgICAgICAgJGguZWFjaChjdXN0b21IZWFkZXJzLCBmdW5jdGlvbihrLHYpIHtcbiAgICAgICAgICAkLnhoci5zZXRSZXF1ZXN0SGVhZGVyKGssIHYpO1xuICAgICAgICB9KTtcbiAgICAgICAgJC54aHIuc2VuZChudWxsKTtcbiAgICAgIH07XG5cbiAgICAgICQucHJlcHJvY2Vzc0ZpbmlzaGVkID0gZnVuY3Rpb24oKXtcbiAgICAgICAgJC5wcmVwcm9jZXNzU3RhdGUgPSAyO1xuICAgICAgICAkLnNlbmQoKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIHNlbmQoKSB1cGxvYWRzIHRoZSBhY3R1YWwgZGF0YSBpbiBhIFBPU1QgY2FsbFxuICAgICAgJC5zZW5kID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHByZXByb2Nlc3MgPSAkLmdldE9wdCgncHJlcHJvY2VzcycpO1xuICAgICAgICBpZih0eXBlb2YgcHJlcHJvY2VzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHN3aXRjaCgkLnByZXByb2Nlc3NTdGF0ZSkge1xuICAgICAgICAgIGNhc2UgMDogJC5wcmVwcm9jZXNzU3RhdGUgPSAxOyBwcmVwcm9jZXNzKCQpOyByZXR1cm47XG4gICAgICAgICAgY2FzZSAxOiByZXR1cm47XG4gICAgICAgICAgY2FzZSAyOiBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYoJC5nZXRPcHQoJ3Rlc3RDaHVua3MnKSAmJiAhJC50ZXN0ZWQpIHtcbiAgICAgICAgICAkLnRlc3QoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdXAgcmVxdWVzdCBhbmQgbGlzdGVuIGZvciBldmVudFxuICAgICAgICAkLnhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICAgIC8vIFByb2dyZXNzXG4gICAgICAgICQueGhyLnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGZ1bmN0aW9uKGUpe1xuICAgICAgICAgIGlmKCAobmV3IERhdGUpIC0gJC5sYXN0UHJvZ3Jlc3NDYWxsYmFjayA+ICQuZ2V0T3B0KCd0aHJvdHRsZVByb2dyZXNzQ2FsbGJhY2tzJykgKiAxMDAwICkge1xuICAgICAgICAgICAgJC5jYWxsYmFjaygncHJvZ3Jlc3MnKTtcbiAgICAgICAgICAgICQubGFzdFByb2dyZXNzQ2FsbGJhY2sgPSAobmV3IERhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAkLmxvYWRlZD1lLmxvYWRlZHx8MDtcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAkLmxvYWRlZCA9IDA7XG4gICAgICAgICQucGVuZGluZ1JldHJ5ID0gZmFsc2U7XG4gICAgICAgICQuY2FsbGJhY2soJ3Byb2dyZXNzJyk7XG5cbiAgICAgICAgLy8gRG9uZSAoZWl0aGVyIGRvbmUsIGZhaWxlZCBvciByZXRyeSlcbiAgICAgICAgdmFyIGRvbmVIYW5kbGVyID0gZnVuY3Rpb24oZSl7XG4gICAgICAgICAgdmFyIHN0YXR1cyA9ICQuc3RhdHVzKCk7XG4gICAgICAgICAgaWYoc3RhdHVzPT0nc3VjY2Vzcyd8fHN0YXR1cz09J2Vycm9yJykge1xuICAgICAgICAgICAgJC5jYWxsYmFjayhzdGF0dXMsICQubWVzc2FnZSgpKTtcbiAgICAgICAgICAgICQucmVzdW1hYmxlT2JqLnVwbG9hZE5leHRDaHVuaygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkLmNhbGxiYWNrKCdyZXRyeScsICQubWVzc2FnZSgpKTtcbiAgICAgICAgICAgICQuYWJvcnQoKTtcbiAgICAgICAgICAgICQucmV0cmllcysrO1xuICAgICAgICAgICAgdmFyIHJldHJ5SW50ZXJ2YWwgPSAkLmdldE9wdCgnY2h1bmtSZXRyeUludGVydmFsJyk7XG4gICAgICAgICAgICBpZihyZXRyeUludGVydmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgJC5wZW5kaW5nUmV0cnkgPSB0cnVlO1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KCQuc2VuZCwgcmV0cnlJbnRlcnZhbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAkLnNlbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgICQueGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBkb25lSGFuZGxlciwgZmFsc2UpO1xuICAgICAgICAkLnhoci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGRvbmVIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgICQueGhyLmFkZEV2ZW50TGlzdGVuZXIoJ3RpbWVvdXQnLCBkb25lSGFuZGxlciwgZmFsc2UpO1xuXG4gICAgICAgIC8vIFNldCB1cCB0aGUgYmFzaWMgcXVlcnkgZGF0YSBmcm9tIFJlc3VtYWJsZVxuICAgICAgICB2YXIgcXVlcnkgPSBbXG4gICAgICAgICAgWydjaHVua051bWJlclBhcmFtZXRlck5hbWUnLCAkLm9mZnNldCArIDFdLFxuICAgICAgICAgIFsnY2h1bmtTaXplUGFyYW1ldGVyTmFtZScsICQuZ2V0T3B0KCdjaHVua1NpemUnKV0sXG4gICAgICAgICAgWydjdXJyZW50Q2h1bmtTaXplUGFyYW1ldGVyTmFtZScsICQuZW5kQnl0ZSAtICQuc3RhcnRCeXRlXSxcbiAgICAgICAgICBbJ3RvdGFsU2l6ZVBhcmFtZXRlck5hbWUnLCAkLmZpbGVPYmpTaXplXSxcbiAgICAgICAgICBbJ3R5cGVQYXJhbWV0ZXJOYW1lJywgJC5maWxlT2JqVHlwZV0sXG4gICAgICAgICAgWydpZGVudGlmaWVyUGFyYW1ldGVyTmFtZScsICQuZmlsZU9iai51bmlxdWVJZGVudGlmaWVyXSxcbiAgICAgICAgICBbJ2ZpbGVOYW1lUGFyYW1ldGVyTmFtZScsICQuZmlsZU9iai5maWxlTmFtZV0sXG4gICAgICAgICAgWydyZWxhdGl2ZVBhdGhQYXJhbWV0ZXJOYW1lJywgJC5maWxlT2JqLnJlbGF0aXZlUGF0aF0sXG4gICAgICAgICAgWyd0b3RhbENodW5rc1BhcmFtZXRlck5hbWUnLCAkLmZpbGVPYmouY2h1bmtzLmxlbmd0aF0sXG4gICAgICAgIF0uZmlsdGVyKGZ1bmN0aW9uKHBhaXIpe1xuICAgICAgICAgIC8vIGluY2x1ZGUgaXRlbXMgdGhhdCByZXNvbHZlIHRvIHRydXRoeSB2YWx1ZXNcbiAgICAgICAgICAvLyBpLmUuIGV4Y2x1ZGUgZmFsc2UsIG51bGwsIHVuZGVmaW5lZCBhbmQgZW1wdHkgc3RyaW5nc1xuICAgICAgICAgIHJldHVybiAkLmdldE9wdChwYWlyWzBdKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnJlZHVjZShmdW5jdGlvbihxdWVyeSwgcGFpcil7XG4gICAgICAgICAgLy8gYXNzaWduIHF1ZXJ5IGtleS92YWx1ZVxuICAgICAgICAgIHF1ZXJ5WyQuZ2V0T3B0KHBhaXJbMF0pXSA9IHBhaXJbMV07XG4gICAgICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIC8vIE1peCBpbiBjdXN0b20gZGF0YVxuICAgICAgICB2YXIgY3VzdG9tUXVlcnkgPSAkLmdldE9wdCgncXVlcnknKTtcbiAgICAgICAgaWYodHlwZW9mIGN1c3RvbVF1ZXJ5ID09ICdmdW5jdGlvbicpIGN1c3RvbVF1ZXJ5ID0gY3VzdG9tUXVlcnkoJC5maWxlT2JqLCAkKTtcbiAgICAgICAgJGguZWFjaChjdXN0b21RdWVyeSwgZnVuY3Rpb24oayx2KXtcbiAgICAgICAgICBxdWVyeVtrXSA9IHY7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBmdW5jID0gKCQuZmlsZU9iai5maWxlLnNsaWNlID8gJ3NsaWNlJyA6ICgkLmZpbGVPYmouZmlsZS5tb3pTbGljZSA/ICdtb3pTbGljZScgOiAoJC5maWxlT2JqLmZpbGUud2Via2l0U2xpY2UgPyAnd2Via2l0U2xpY2UnIDogJ3NsaWNlJykpKTtcbiAgICAgICAgdmFyIGJ5dGVzID0gJC5maWxlT2JqLmZpbGVbZnVuY10oJC5zdGFydEJ5dGUsICQuZW5kQnl0ZSwgJC5nZXRPcHQoJ3NldENodW5rVHlwZUZyb21GaWxlJykgPyAkLmZpbGVPYmouZmlsZS50eXBlIDogXCJcIik7XG4gICAgICAgIHZhciBkYXRhID0gbnVsbDtcbiAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuXG4gICAgICAgIHZhciBwYXJhbWV0ZXJOYW1lc3BhY2UgPSAkLmdldE9wdCgncGFyYW1ldGVyTmFtZXNwYWNlJyk7XG4gICAgICAgICAgICAgICAgaWYgKCQuZ2V0T3B0KCdtZXRob2QnKSA9PT0gJ29jdGV0Jykge1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgZGF0YSBmcm9tIHRoZSBxdWVyeSBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBieXRlcztcbiAgICAgICAgICAgICAgICAgICAgJGguZWFjaChxdWVyeSwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKFtlbmNvZGVVUklDb21wb25lbnQocGFyYW1ldGVyTmFtZXNwYWNlICsgayksIGVuY29kZVVSSUNvbXBvbmVudCh2KV0uam9pbignPScpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGRhdGEgZnJvbSB0aGUgcXVlcnkgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgICRoLmVhY2gocXVlcnksIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmFwcGVuZChwYXJhbWV0ZXJOYW1lc3BhY2UgKyBrLCB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKFtlbmNvZGVVUklDb21wb25lbnQocGFyYW1ldGVyTmFtZXNwYWNlICsgayksIGVuY29kZVVSSUNvbXBvbmVudCh2KV0uam9pbignPScpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkLmdldE9wdCgnY2h1bmtGb3JtYXQnKSA9PSAnYmxvYicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuYXBwZW5kKHBhcmFtZXRlck5hbWVzcGFjZSArICQuZ2V0T3B0KCdmaWxlUGFyYW1ldGVyTmFtZScpLCBieXRlcywgJC5maWxlT2JqLmZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgkLmdldE9wdCgnY2h1bmtGb3JtYXQnKSA9PSAnYmFzZTY0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyLm9ubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5hcHBlbmQocGFyYW1ldGVyTmFtZXNwYWNlICsgJC5nZXRPcHQoJ2ZpbGVQYXJhbWV0ZXJOYW1lJyksIGZyLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJC54aHIuc2VuZChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZyLnJlYWRBc0RhdGFVUkwoYnl0ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgIHZhciB0YXJnZXQgPSAkaC5nZXRUYXJnZXQoJ3VwbG9hZCcsIHBhcmFtcyk7XG4gICAgICAgIHZhciBtZXRob2QgPSAkLmdldE9wdCgndXBsb2FkTWV0aG9kJyk7XG5cbiAgICAgICAgJC54aHIub3BlbihtZXRob2QsIHRhcmdldCk7XG4gICAgICAgIGlmICgkLmdldE9wdCgnbWV0aG9kJykgPT09ICdvY3RldCcpIHtcbiAgICAgICAgICAkLnhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyk7XG4gICAgICAgIH1cbiAgICAgICAgJC54aHIudGltZW91dCA9ICQuZ2V0T3B0KCd4aHJUaW1lb3V0Jyk7XG4gICAgICAgICQueGhyLndpdGhDcmVkZW50aWFscyA9ICQuZ2V0T3B0KCd3aXRoQ3JlZGVudGlhbHMnKTtcbiAgICAgICAgLy8gQWRkIGRhdGEgZnJvbSBoZWFkZXIgb3B0aW9uc1xuICAgICAgICB2YXIgY3VzdG9tSGVhZGVycyA9ICQuZ2V0T3B0KCdoZWFkZXJzJyk7XG4gICAgICAgIGlmKHR5cGVvZiBjdXN0b21IZWFkZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY3VzdG9tSGVhZGVycyA9IGN1c3RvbUhlYWRlcnMoJC5maWxlT2JqLCAkKTtcbiAgICAgICAgfVxuXG4gICAgICAgICRoLmVhY2goY3VzdG9tSGVhZGVycywgZnVuY3Rpb24oayx2KSB7XG4gICAgICAgICAgJC54aHIuc2V0UmVxdWVzdEhlYWRlcihrLCB2KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoJC5nZXRPcHQoJ2NodW5rRm9ybWF0JykgPT0gJ2Jsb2InKSB7XG4gICAgICAgICAgICAgICAgICAgICQueGhyLnNlbmQoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgICQuYWJvcnQgPSBmdW5jdGlvbigpe1xuICAgICAgICAvLyBBYm9ydCBhbmQgcmVzZXRcbiAgICAgICAgaWYoJC54aHIpICQueGhyLmFib3J0KCk7XG4gICAgICAgICQueGhyID0gbnVsbDtcbiAgICAgIH07XG4gICAgICAkLnN0YXR1cyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vIFJldHVybnM6ICdwZW5kaW5nJywgJ3VwbG9hZGluZycsICdzdWNjZXNzJywgJ2Vycm9yJ1xuICAgICAgICBpZigkLnBlbmRpbmdSZXRyeSkge1xuICAgICAgICAgIC8vIGlmIHBlbmRpbmcgcmV0cnkgdGhlbiB0aGF0J3MgZWZmZWN0aXZlbHkgdGhlIHNhbWUgYXMgYWN0aXZlbHkgdXBsb2FkaW5nLFxuICAgICAgICAgIC8vIHRoZXJlIG1pZ2h0IGp1c3QgYmUgYSBzbGlnaHQgZGVsYXkgYmVmb3JlIHRoZSByZXRyeSBzdGFydHNcbiAgICAgICAgICByZXR1cm4oJ3VwbG9hZGluZycpO1xuICAgICAgICB9IGVsc2UgaWYoISQueGhyKSB7XG4gICAgICAgICAgcmV0dXJuKCdwZW5kaW5nJyk7XG4gICAgICAgIH0gZWxzZSBpZigkLnhoci5yZWFkeVN0YXRlPDQpIHtcbiAgICAgICAgICAvLyBTdGF0dXMgaXMgcmVhbGx5ICdPUEVORUQnLCAnSEVBREVSU19SRUNFSVZFRCcgb3IgJ0xPQURJTkcnIC0gbWVhbmluZyB0aGF0IHN0dWZmIGlzIGhhcHBlbmluZ1xuICAgICAgICAgIHJldHVybigndXBsb2FkaW5nJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYoJC54aHIuc3RhdHVzID09IDIwMCB8fCAkLnhoci5zdGF0dXMgPT0gMjAxKSB7XG4gICAgICAgICAgICAvLyBIVFRQIDIwMCwgMjAxIChjcmVhdGVkKVxuICAgICAgICAgICAgcmV0dXJuKCdzdWNjZXNzJyk7XG4gICAgICAgICAgfSBlbHNlIGlmKCRoLmNvbnRhaW5zKCQuZ2V0T3B0KCdwZXJtYW5lbnRFcnJvcnMnKSwgJC54aHIuc3RhdHVzKSB8fCAkLnJldHJpZXMgPj0gJC5nZXRPcHQoJ21heENodW5rUmV0cmllcycpKSB7XG4gICAgICAgICAgICAvLyBIVFRQIDQxNS81MDAvNTAxLCBwZXJtYW5lbnQgZXJyb3JcbiAgICAgICAgICAgIHJldHVybignZXJyb3InKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLCBidXQgd2UnbGwgcmVzZXQgYW5kIHF1ZXVlIGEgcmV0cnlcbiAgICAgICAgICAgIC8vIGEgbGlrZWx5IGNhc2UgZm9yIHRoaXMgd291bGQgYmUgNTAzIHNlcnZpY2UgdW5hdmFpbGFibGVcbiAgICAgICAgICAgICQuYWJvcnQoKTtcbiAgICAgICAgICAgIHJldHVybigncGVuZGluZycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgICQubWVzc2FnZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybigkLnhociA/ICQueGhyLnJlc3BvbnNlVGV4dCA6ICcnKTtcbiAgICAgIH07XG4gICAgICAkLnByb2dyZXNzID0gZnVuY3Rpb24ocmVsYXRpdmUpe1xuICAgICAgICBpZih0eXBlb2YocmVsYXRpdmUpPT09J3VuZGVmaW5lZCcpIHJlbGF0aXZlID0gZmFsc2U7XG4gICAgICAgIHZhciBmYWN0b3IgPSAocmVsYXRpdmUgPyAoJC5lbmRCeXRlLSQuc3RhcnRCeXRlKS8kLmZpbGVPYmpTaXplIDogMSk7XG4gICAgICAgIGlmKCQucGVuZGluZ1JldHJ5KSByZXR1cm4oMCk7XG4gICAgICAgIGlmKCEkLnhociB8fCAhJC54aHIuc3RhdHVzKSBmYWN0b3IqPS45NTtcbiAgICAgICAgdmFyIHMgPSAkLnN0YXR1cygpO1xuICAgICAgICBzd2l0Y2gocyl7XG4gICAgICAgIGNhc2UgJ3N1Y2Nlc3MnOlxuICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgcmV0dXJuKDEqZmFjdG9yKTtcbiAgICAgICAgY2FzZSAncGVuZGluZyc6XG4gICAgICAgICAgcmV0dXJuKDAqZmFjdG9yKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4oJC5sb2FkZWQvKCQuZW5kQnl0ZS0kLnN0YXJ0Qnl0ZSkqZmFjdG9yKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybih0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBRVUVVRVxuICAgICQudXBsb2FkTmV4dENodW5rID0gZnVuY3Rpb24oKXtcbiAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuXG4gICAgICAvLyBJbiBzb21lIGNhc2VzIChzdWNoIGFzIHZpZGVvcykgaXQncyByZWFsbHkgaGFuZHkgdG8gdXBsb2FkIHRoZSBmaXJzdFxuICAgICAgLy8gYW5kIGxhc3QgY2h1bmsgb2YgYSBmaWxlIHF1aWNrbHk7IHRoaXMgbGV0J3MgdGhlIHNlcnZlciBjaGVjayB0aGUgZmlsZSdzXG4gICAgICAvLyBtZXRhZGF0YSBhbmQgZGV0ZXJtaW5lIGlmIHRoZXJlJ3MgZXZlbiBhIHBvaW50IGluIGNvbnRpbnVpbmcuXG4gICAgICBpZiAoJC5nZXRPcHQoJ3ByaW9yaXRpemVGaXJzdEFuZExhc3RDaHVuaycpKSB7XG4gICAgICAgICRoLmVhY2goJC5maWxlcywgZnVuY3Rpb24oZmlsZSl7XG4gICAgICAgICAgaWYoZmlsZS5jaHVua3MubGVuZ3RoICYmIGZpbGUuY2h1bmtzWzBdLnN0YXR1cygpPT0ncGVuZGluZycgJiYgZmlsZS5jaHVua3NbMF0ucHJlcHJvY2Vzc1N0YXRlID09PSAwKSB7XG4gICAgICAgICAgICBmaWxlLmNodW5rc1swXS5zZW5kKCk7XG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4oZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihmaWxlLmNodW5rcy5sZW5ndGg+MSAmJiBmaWxlLmNodW5rc1tmaWxlLmNodW5rcy5sZW5ndGgtMV0uc3RhdHVzKCk9PSdwZW5kaW5nJyAmJiBmaWxlLmNodW5rc1tmaWxlLmNodW5rcy5sZW5ndGgtMV0ucHJlcHJvY2Vzc1N0YXRlID09PSAwKSB7XG4gICAgICAgICAgICBmaWxlLmNodW5rc1tmaWxlLmNodW5rcy5sZW5ndGgtMV0uc2VuZCgpO1xuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuKGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZihmb3VuZCkgcmV0dXJuKHRydWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBOb3csIHNpbXBseSBsb29rIGZvciB0aGUgbmV4dCwgYmVzdCB0aGluZyB0byB1cGxvYWRcbiAgICAgICRoLmVhY2goJC5maWxlcywgZnVuY3Rpb24oZmlsZSl7XG4gICAgICAgIGlmKGZpbGUuaXNQYXVzZWQoKT09PWZhbHNlKXtcbiAgICAgICAgICRoLmVhY2goZmlsZS5jaHVua3MsIGZ1bmN0aW9uKGNodW5rKXtcbiAgICAgICAgICAgaWYoY2h1bmsuc3RhdHVzKCk9PSdwZW5kaW5nJyAmJiBjaHVuay5wcmVwcm9jZXNzU3RhdGUgPT09IDApIHtcbiAgICAgICAgICAgICBjaHVuay5zZW5kKCk7XG4gICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgIHJldHVybihmYWxzZSk7XG4gICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZihmb3VuZCkgcmV0dXJuKGZhbHNlKTtcbiAgICAgIH0pO1xuICAgICAgaWYoZm91bmQpIHJldHVybih0cnVlKTtcblxuICAgICAgLy8gVGhlIGFyZSBubyBtb3JlIG91dHN0YW5kaW5nIGNodW5rcyB0byB1cGxvYWQsIGNoZWNrIGlzIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuICAgICAgdmFyIG91dHN0YW5kaW5nID0gZmFsc2U7XG4gICAgICAkaC5lYWNoKCQuZmlsZXMsIGZ1bmN0aW9uKGZpbGUpe1xuICAgICAgICBpZighZmlsZS5pc0NvbXBsZXRlKCkpIHtcbiAgICAgICAgICBvdXRzdGFuZGluZyA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZighb3V0c3RhbmRpbmcpIHtcbiAgICAgICAgLy8gQWxsIGNodW5rcyBoYXZlIGJlZW4gdXBsb2FkZWQsIGNvbXBsZXRlXG4gICAgICAgICQuZmlyZSgnY29tcGxldGUnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybihmYWxzZSk7XG4gICAgfTtcblxuXG4gICAgLy8gUFVCTElDIE1FVEhPRFMgRk9SIFJFU1VNQUJMRS5KU1xuICAgICQuYXNzaWduQnJvd3NlID0gZnVuY3Rpb24oZG9tTm9kZXMsIGlzRGlyZWN0b3J5KXtcbiAgICAgIGlmKHR5cGVvZihkb21Ob2Rlcy5sZW5ndGgpPT0ndW5kZWZpbmVkJykgZG9tTm9kZXMgPSBbZG9tTm9kZXNdO1xuXG4gICAgICAkaC5lYWNoKGRvbU5vZGVzLCBmdW5jdGlvbihkb21Ob2RlKSB7XG4gICAgICAgIHZhciBpbnB1dDtcbiAgICAgICAgaWYoZG9tTm9kZS50YWdOYW1lPT09J0lOUFVUJyAmJiBkb21Ob2RlLnR5cGU9PT0nZmlsZScpe1xuICAgICAgICAgIGlucHV0ID0gZG9tTm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2ZpbGUnKTtcbiAgICAgICAgICBpbnB1dC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgIGRvbU5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgaW5wdXQuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgICAgICBpbnB1dC5zdHlsZS5kaXNwbGF5PSdibG9jayc7XG4gICAgICAgICAgICBpbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgaW5wdXQuY2xpY2soKTtcbiAgICAgICAgICAgIGlucHV0LnN0eWxlLmRpc3BsYXk9J25vbmUnO1xuICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICBkb21Ob2RlLmFwcGVuZENoaWxkKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF4RmlsZXMgPSAkLmdldE9wdCgnbWF4RmlsZXMnKTtcbiAgICAgICAgaWYgKHR5cGVvZihtYXhGaWxlcyk9PT0ndW5kZWZpbmVkJ3x8bWF4RmlsZXMhPTEpe1xuICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCAnbXVsdGlwbGUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnB1dC5yZW1vdmVBdHRyaWJ1dGUoJ211bHRpcGxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoaXNEaXJlY3Rvcnkpe1xuICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgnd2Via2l0ZGlyZWN0b3J5JywgJ3dlYmtpdGRpcmVjdG9yeScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlucHV0LnJlbW92ZUF0dHJpYnV0ZSgnd2Via2l0ZGlyZWN0b3J5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpbGVUeXBlcyA9ICQuZ2V0T3B0KCdmaWxlVHlwZScpO1xuICAgICAgICBpZiAodHlwZW9mIChmaWxlVHlwZXMpICE9PSAndW5kZWZpbmVkJyAmJiBmaWxlVHlwZXMubGVuZ3RoID49IDEpIHtcbiAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ2FjY2VwdCcsIGZpbGVUeXBlcy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuICcuJyArIGUgfSkuam9pbignLCcpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpbnB1dC5yZW1vdmVBdHRyaWJ1dGUoJ2FjY2VwdCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gbmV3IGZpbGVzIGFyZSBhZGRlZCwgc2ltcGx5IGFwcGVuZCB0aGVtIHRvIHRoZSBvdmVyYWxsIGxpc3RcbiAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgYXBwZW5kRmlsZXNGcm9tRmlsZUxpc3QoZS50YXJnZXQuZmlsZXMsZSk7XG4gICAgICAgICAgdmFyIGNsZWFySW5wdXQgPSAkLmdldE9wdCgnY2xlYXJJbnB1dCcpO1xuICAgICAgICAgIGlmIChjbGVhcklucHV0KSB7XG4gICAgICAgICAgICBlLnRhcmdldC52YWx1ZSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICAkLmFzc2lnbkRyb3AgPSBmdW5jdGlvbihkb21Ob2Rlcyl7XG4gICAgICBpZih0eXBlb2YoZG9tTm9kZXMubGVuZ3RoKT09J3VuZGVmaW5lZCcpIGRvbU5vZGVzID0gW2RvbU5vZGVzXTtcblxuICAgICAgJGguZWFjaChkb21Ob2RlcywgZnVuY3Rpb24oZG9tTm9kZSkge1xuICAgICAgICBkb21Ob2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgcHJldmVudERlZmF1bHQsIGZhbHNlKTtcbiAgICAgICAgZG9tTm9kZS5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW50ZXInLCBwcmV2ZW50RGVmYXVsdCwgZmFsc2UpO1xuICAgICAgICBkb21Ob2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCBvbkRyb3AsIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgJC51bkFzc2lnbkRyb3AgPSBmdW5jdGlvbihkb21Ob2Rlcykge1xuICAgICAgaWYgKHR5cGVvZihkb21Ob2Rlcy5sZW5ndGgpID09ICd1bmRlZmluZWQnKSBkb21Ob2RlcyA9IFtkb21Ob2Rlc107XG5cbiAgICAgICRoLmVhY2goZG9tTm9kZXMsIGZ1bmN0aW9uKGRvbU5vZGUpIHtcbiAgICAgICAgZG9tTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsIHByZXZlbnREZWZhdWx0KTtcbiAgICAgICAgZG9tTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnZW50ZXInLCBwcmV2ZW50RGVmYXVsdCk7XG4gICAgICAgIGRvbU5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJvcCcsIG9uRHJvcCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgICQuaXNVcGxvYWRpbmcgPSBmdW5jdGlvbigpe1xuICAgICAgdmFyIHVwbG9hZGluZyA9IGZhbHNlO1xuICAgICAgJGguZWFjaCgkLmZpbGVzLCBmdW5jdGlvbihmaWxlKXtcbiAgICAgICAgaWYgKGZpbGUuaXNVcGxvYWRpbmcoKSkge1xuICAgICAgICAgIHVwbG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4odXBsb2FkaW5nKTtcbiAgICB9O1xuICAgICQudXBsb2FkID0gZnVuY3Rpb24oKXtcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCBzdGFydCB0b28gbWFueSB1cGxvYWRzIGF0IG9uY2VcbiAgICAgIGlmKCQuaXNVcGxvYWRpbmcoKSkgcmV0dXJuO1xuICAgICAgLy8gS2ljayBvZmYgdGhlIHF1ZXVlXG4gICAgICAkLmZpcmUoJ3VwbG9hZFN0YXJ0Jyk7XG4gICAgICBmb3IgKHZhciBudW09MTsgbnVtPD0kLmdldE9wdCgnc2ltdWx0YW5lb3VzVXBsb2FkcycpOyBudW0rKykge1xuICAgICAgICAkLnVwbG9hZE5leHRDaHVuaygpO1xuICAgICAgfVxuICAgIH07XG4gICAgJC5wYXVzZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAvLyBSZXN1bWUgYWxsIGNodW5rcyBjdXJyZW50bHkgYmVpbmcgdXBsb2FkZWRcbiAgICAgICRoLmVhY2goJC5maWxlcywgZnVuY3Rpb24oZmlsZSl7XG4gICAgICAgIGZpbGUuYWJvcnQoKTtcbiAgICAgIH0pO1xuICAgICAgJC5maXJlKCdwYXVzZScpO1xuICAgIH07XG4gICAgJC5jYW5jZWwgPSBmdW5jdGlvbigpe1xuICAgICAgJC5maXJlKCdiZWZvcmVDYW5jZWwnKTtcbiAgICAgIGZvcih2YXIgaSA9ICQuZmlsZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgJC5maWxlc1tpXS5jYW5jZWwoKTtcbiAgICAgIH1cbiAgICAgICQuZmlyZSgnY2FuY2VsJyk7XG4gICAgfTtcbiAgICAkLnByb2dyZXNzID0gZnVuY3Rpb24oKXtcbiAgICAgIHZhciB0b3RhbERvbmUgPSAwO1xuICAgICAgdmFyIHRvdGFsU2l6ZSA9IDA7XG4gICAgICAvLyBSZXN1bWUgYWxsIGNodW5rcyBjdXJyZW50bHkgYmVpbmcgdXBsb2FkZWRcbiAgICAgICRoLmVhY2goJC5maWxlcywgZnVuY3Rpb24oZmlsZSl7XG4gICAgICAgIHRvdGFsRG9uZSArPSBmaWxlLnByb2dyZXNzKCkqZmlsZS5zaXplO1xuICAgICAgICB0b3RhbFNpemUgKz0gZmlsZS5zaXplO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4odG90YWxTaXplPjAgPyB0b3RhbERvbmUvdG90YWxTaXplIDogMCk7XG4gICAgfTtcbiAgICAkLmFkZEZpbGUgPSBmdW5jdGlvbihmaWxlLCBldmVudCl7XG4gICAgICBhcHBlbmRGaWxlc0Zyb21GaWxlTGlzdChbZmlsZV0sIGV2ZW50KTtcbiAgICB9O1xuICAgICQuYWRkRmlsZXMgPSBmdW5jdGlvbihmaWxlcywgZXZlbnQpe1xuICAgICAgYXBwZW5kRmlsZXNGcm9tRmlsZUxpc3QoZmlsZXMsIGV2ZW50KTtcbiAgICB9O1xuICAgICQucmVtb3ZlRmlsZSA9IGZ1bmN0aW9uKGZpbGUpe1xuICAgICAgZm9yKHZhciBpID0gJC5maWxlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZigkLmZpbGVzW2ldID09PSBmaWxlKSB7XG4gICAgICAgICAgJC5maWxlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgICQuZ2V0RnJvbVVuaXF1ZUlkZW50aWZpZXIgPSBmdW5jdGlvbih1bmlxdWVJZGVudGlmaWVyKXtcbiAgICAgIHZhciByZXQgPSBmYWxzZTtcbiAgICAgICRoLmVhY2goJC5maWxlcywgZnVuY3Rpb24oZil7XG4gICAgICAgIGlmKGYudW5pcXVlSWRlbnRpZmllcj09dW5pcXVlSWRlbnRpZmllcikgcmV0ID0gZjtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuKHJldCk7XG4gICAgfTtcbiAgICAkLmdldFNpemUgPSBmdW5jdGlvbigpe1xuICAgICAgdmFyIHRvdGFsU2l6ZSA9IDA7XG4gICAgICAkaC5lYWNoKCQuZmlsZXMsIGZ1bmN0aW9uKGZpbGUpe1xuICAgICAgICB0b3RhbFNpemUgKz0gZmlsZS5zaXplO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4odG90YWxTaXplKTtcbiAgICB9O1xuICAgICQuaGFuZGxlRHJvcEV2ZW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIG9uRHJvcChlKTtcbiAgICB9O1xuICAgICQuaGFuZGxlQ2hhbmdlRXZlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgYXBwZW5kRmlsZXNGcm9tRmlsZUxpc3QoZS50YXJnZXQuZmlsZXMsIGUpO1xuICAgICAgZS50YXJnZXQudmFsdWUgPSAnJztcbiAgICB9O1xuICAgICQudXBkYXRlUXVlcnkgPSBmdW5jdGlvbihxdWVyeSl7XG4gICAgICAgICQub3B0cy5xdWVyeSA9IHF1ZXJ5O1xuICAgIH07XG5cbiAgICByZXR1cm4odGhpcyk7XG4gIH07XG5cblxuICAvLyBOb2RlLmpzLXN0eWxlIGV4cG9ydCBmb3IgTm9kZSBhbmQgQ29tcG9uZW50XG4gIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBSZXN1bWFibGU7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBBTUQvcmVxdWlyZWpzOiBEZWZpbmUgdGhlIG1vZHVsZVxuICAgIGRlZmluZShmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIFJlc3VtYWJsZTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBCcm93c2VyOiBFeHBvc2UgdG8gd2luZG93XG4gICAgd2luZG93LlJlc3VtYWJsZSA9IFJlc3VtYWJsZTtcbiAgfVxuXG59KSgpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/resumablejs/resumable.js\n");

/***/ }),

/***/ "./src/lib/components/Upload.react.js":
/*!********************************************!*\
  !*** ./src/lib/components/Upload.react.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(/*! react */ \"react\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _resumablejs = __webpack_require__(/*! resumablejs */ \"./node_modules/resumablejs/resumable.js\");\n\nvar _resumablejs2 = _interopRequireDefault(_resumablejs);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Upload = function (_Component) {\n    _inherits(Upload, _Component);\n\n    function Upload(props) {\n        _classCallCheck(this, Upload);\n\n        var _this = _possibleConstructorReturn(this, (Upload.__proto__ || Object.getPrototypeOf(Upload)).call(this, props));\n\n        _this.state = {\n            progressBar: 0,\n            messageStatus: '',\n            fileList: { files: [] },\n            isPaused: false,\n            isUploading: false,\n            isHovered: false,\n            isComplete: false\n        };\n        _this.toggleHovered = _this.toggleHovered.bind(_this);\n        _this.cancelUpload = _this.cancelUpload.bind(_this);\n        _this.pauseUpload = _this.pauseUpload.bind(_this);\n        _this.startUpload = _this.startUpload.bind(_this);\n        _this.resumable = null;\n        return _this;\n    }\n\n    _createClass(Upload, [{\n        key: 'componentDidMount',\n        value: function componentDidMount() {\n            var _this2 = this;\n\n            var ResumableField = new _resumablejs2.default({\n                target: this.props.service,\n                query: {},\n                fileType: this.props.filetypes,\n                maxFiles: this.props.maxFiles,\n                maxFileSize: this.props.maxFileSize,\n                fileTypeErrorCallback: function fileTypeErrorCallback() {\n                    _this2.setState({\n                        messageStatus: 'Invalid file type!'\n                    });\n                },\n                testMethod: 'post',\n                testChunks: false,\n                headers: {},\n                chunkSize: this.props.chunkSize,\n                simultaneousUploads: this.props.simultaneousUploads,\n                forceChunkSize: false\n            });\n\n            ResumableField.assignBrowse(this.uploader);\n\n            // Enable or Disable DragAnd Drop\n            if (this.props.disableDragAndDrop === false) {\n                ResumableField.assignDrop(this.dropZone);\n            }\n\n            ResumableField.on('fileAdded', function (file) {\n                _this2.setState({\n                    messageStatus: _this2.props.fileAddedMessage || ' Starting upload! of ' + file.fileName,\n                    isComplete: false\n                });\n\n                if (typeof _this2.props.onFileAdded === 'function') {\n                    _this2.props.onFileAdded(file, _this2.resumable);\n                } else {\n                    ResumableField.upload();\n                }\n            });\n\n            ResumableField.on('fileSuccess', function (file, fileServer) {\n\n                if (_this2.props.fileNameServer) {\n                    var objectServer = JSON.parse(fileServer);\n                    file.fileName = objectServer[_this2.props.fileNameServer];\n                } else {\n                    file.fileName = fileServer;\n                }\n                var currentFiles = _this2.state.fileList.files;\n                currentFiles.push(file);\n\n                var fileNames = _this2.props.fileNames;\n                fileNames.push(file.fileName);\n\n                if (_this2.props.setProps) {\n                    _this2.props.setProps({\n                        fileNames: fileNames\n                    });\n                }\n                _this2.setState({\n                    fileList: { files: currentFiles },\n                    isComplete: true,\n                    messageStatus: _this2.props.completedMessage + file.fileName || fileServer\n                }, function () {\n                    if (typeof _this2.props.onFileSuccess === 'function') {\n                        _this2.props.onFileSuccess(file, fileServer);\n                    }\n                });\n            });\n\n            ResumableField.on('progress', function () {\n\n                _this2.setState({\n                    isUploading: ResumableField.isUploading()\n                });\n\n                if (ResumableField.progress() * 100 < 100) {\n                    _this2.setState({\n                        messageStatus: parseInt(ResumableField.progress() * 100, 10) + '%',\n                        progressBar: ResumableField.progress() * 100\n                    });\n                } else {\n                    setTimeout(function () {\n                        _this2.setState({\n                            progressBar: 0\n                        });\n                    }, 1000);\n                }\n            });\n\n            ResumableField.on('fileError', function (file, errorCount) {\n                _this2.props.onUploadErrorCallback(file, errorCount);\n            });\n\n            this.resumable = ResumableField;\n        }\n    }, {\n        key: 'cancelUpload',\n        value: function cancelUpload() {\n            this.resumable.cancel();\n\n            this.setState({\n                fileList: { files: [] }\n            });\n        }\n    }, {\n        key: 'pauseUpload',\n        value: function pauseUpload() {\n            if (!this.state.isPaused) {\n                this.resumable.pause();\n                this.setState({\n                    isPaused: true,\n                    isUploading: true\n                });\n            } else {\n                this.resumable.upload();\n                this.setState({\n                    isPaused: false,\n                    isUploading: true\n                });\n            }\n        }\n    }, {\n        key: 'startUpload',\n        value: function startUpload() {\n            this.setState({\n                isPaused: false\n            });\n        }\n    }, {\n        key: 'toggleHovered',\n        value: function toggleHovered() {\n            this.setState({\n                isHovered: !this.state.isHovered\n            });\n        }\n    }, {\n        key: 'render',\n        value: function render() {\n            var _this3 = this;\n\n            var fileList = null;\n\n            var textLabel = null;\n            if (this.props.textLabel) {\n                textLabel = this.props.textLabel;\n            }\n\n            var startButton = null;\n            if (this.props.startButton) {\n                if (typeof this.props.startButton === 'string' || typeof this.props.startButton === 'boolean') startButton = _react2.default.createElement(\n                    'label',\n                    null,\n                    _react2.default.createElement(\n                        'button',\n                        {\n                            disabled: this.state.isUploading,\n                            className: 'resumable-btn-start',\n                            onClick: this.startUpload },\n                        this.props.startButton && 'upload'\n                    )\n                );else startButton = this.props.startButton;\n            }\n\n            var cancelButton = null;\n            if (this.props.cancelButton) {\n                if (typeof this.props.cancelButton === 'string' || typeof this.props.cancelButton === 'boolean') cancelButton = _react2.default.createElement(\n                    'label',\n                    null,\n                    _react2.default.createElement(\n                        'button',\n                        {\n                            disabled: !this.state.isUploading,\n                            className: 'resumable-btn-cancel',\n                            onClick: this.cancelUpload },\n                        this.props.cancelButton && 'cancel'\n                    )\n                );else cancelButton = this.props.cancelButton;\n            }\n\n            var pauseButton = null;\n            if (this.props.pauseButton) {\n                if (typeof this.props.pauseButton === 'string' || typeof this.props.pauseButton === 'boolean') pauseButton = _react2.default.createElement(\n                    'label',\n                    null,\n                    _react2.default.createElement(\n                        'button',\n                        {\n                            disabled: !this.state.isUploading,\n                            className: 'resumable-btn-pause',\n                            onClick: this.pauseUpload },\n                        this.props.pauseButton && (this.state.isPaused ? 'resume' : 'pause')\n                    )\n                );else pauseButton = this.props.pauseButton;\n            }\n\n            var getStyle = function getStyle() {\n                if (_this3.state.isComplete) {\n                    return _this3.props.completeStyle;\n                } else if (_this3.state.isHovered || _this3.state.isUploading) {\n                    return _this3.props.activeStyle;\n                } else {\n                    return _this3.props.defaultStyle;\n                }\n            };\n\n            var getClass = function getClass() {\n                if (_this3.props.disabledInput) {\n                    return _this3.props.disableClass;\n                } else if (_this3.state.isHovered) {\n                    return _this3.props.hoveredClass;\n                } else if (_this3.state.isUploading) {\n                    return _this3.props.uploadingClass;\n                } else if (_this3.state.isComplete) {\n                    return _this3.props.completeClass;\n                } else if (_this3.state.isPaused) {\n                    return _this3.props.completeClass;\n                } else {\n                    return _this3.props.className;\n                }\n            };\n\n            return _react2.default.createElement(\n                'div',\n                { id: this.props.id, className: getClass(), ref: function ref(node) {\n                        return _this3.dropZone = node;\n                    } },\n                _react2.default.createElement(\n                    'label',\n                    {\n                        style: getStyle(),\n                        onMouseEnter: this.toggleHovered,\n                        onMouseLeave: this.toggleHovered\n                    },\n                    this.state.messageStatus == '' ? textLabel : this.state.messageStatus,\n                    _react2.default.createElement('input', {\n                        ref: function ref(node) {\n                            return _this3.uploader = node;\n                        },\n                        type: 'file',\n                        className: 'btn',\n                        name: this.props.id + '-upload',\n                        accept: this.props.fileAccept || '*',\n                        disabled: this.props.disableInput || false,\n                        style: { 'opacity': '0',\n                            'width': '0.1px%',\n                            'height': '0.1px%',\n                            'position': 'absolute',\n                            'overflow': 'hidden',\n                            'z-index': '-1' }\n                    })\n                ),\n                _react2.default.createElement(\n                    'div',\n                    { className: 'progress',\n                        style: {\n                            display: this.state.progressBar === 0 ? 'none' : 'block'\n                        } },\n                    _react2.default.createElement('div', { className: 'progress-bar',\n                        style: {\n                            width: this.state.progressBar + '%',\n                            height: '100%'\n                        } })\n                ),\n                fileList,\n                startButton,\n                pauseButton,\n                cancelButton\n            );\n        }\n    }]);\n\n    return Upload;\n}(_react.Component);\n\nexports.default = Upload;\n\n\nUpload.propTypes = {\n    /**\n     * Maximum number of files that can be uploaded in one session\n     */\n    maxFiles: _propTypes2.default.number,\n\n    /**\n     * Maximum size per file in bytes.\n     */\n    maxFileSize: _propTypes2.default.number,\n\n    /**\n     * Size of file chunks to send to server.\n     */\n    chunkSize: _propTypes2.default.number,\n\n    /**\n     * Number of simultaneous uploads to select\n     */\n    simultaneousUploads: _propTypes2.default.number,\n\n    /**\n     * The service to send the files to\n     */\n    service: _propTypes2.default.string,\n\n    /**\n     * Class to add to the upload component by default\n     */\n    className: _propTypes2.default.string,\n\n    /**\n     * Class to add to the upload component when it is hovered\n     */\n    hoveredClass: _propTypes2.default.string,\n\n    /**\n     * Class to add to the upload component when it is disabled\n     */\n    disabledClass: _propTypes2.default.string,\n\n    /**\n     * Class to add to the upload component when it is paused\n     */\n    pausedClass: _propTypes2.default.string,\n\n    /**\n     * Class to add to the upload component when it is complete\n     */\n    completeClass: _propTypes2.default.string,\n\n    /**\n     * Class to add to the upload component when it is uploading\n     */\n    uploadingClass: _propTypes2.default.string,\n\n    /**\n     * Style attributes to add to the upload component\n     */\n    defaultStyle: _propTypes2.default.object,\n\n    /**\n     * Style when upload component is hovered over\n     */\n    activeStyle: _propTypes2.default.object,\n\n    /**\n     * Style when upload is completed (upload finished)\n     */\n    completeStyle: _propTypes2.default.object,\n\n    /**\n     * The string to display in the upload component\n     */\n    textLabel: _propTypes2.default.string,\n\n    /**\n     * Message to display when upload completed\n     */\n    completedMessage: _propTypes2.default.string,\n\n    /**\n     * The names of the files uploaded\n     */\n    fileNames: _propTypes2.default.arrayOf(_propTypes2.default.string),\n\n    /**\n     * List of allowed file types, e.g. ['jpg', 'png']\n     */\n    filetypes: _propTypes2.default.arrayOf(_propTypes2.default.string),\n\n    /**\n     * Whether or not to have a start button\n     */\n    startButton: _propTypes2.default.bool,\n\n    /**\n     * Whether or not to have a pause button\n     */\n    pauseButton: _propTypes2.default.bool,\n\n    /**\n     * Whether or not to have a cancel button\n     */\n    cancelButton: _propTypes2.default.bool,\n\n    /**\n     * Whether or not to allow file drag and drop\n     */\n    disableDragAndDrop: _propTypes2.default.bool,\n\n    /**\n     * Dash-supplied function for updating props\n     */\n    setProps: _propTypes2.default.func,\n\n    /**\n     * User supplied id of this component\n     */\n    id: _propTypes2.default.string\n\n};\n\nUpload.defaultProps = {\n    maxFiles: 1,\n    maxFileSize: 1024 * 1024 * 10,\n    chunkSize: 1024 * 1024,\n    simultaneuosUploads: 1,\n    service: '/upload',\n    className: 'resumable-default',\n    hoveredClass: 'resumable-hovered',\n    completeClass: 'resumable-complete',\n    disabledClass: 'resumable-disabled',\n    pausedClass: 'resumable-paused',\n    uploadingClass: 'resumable-uploading',\n    defaultStyle: {},\n    activeStyle: {},\n    completeStyle: {},\n    textLabel: 'Click Here to Select a File',\n    completedMessage: 'Complete! ',\n    fileNames: [],\n    filetypes: undefined,\n    startButton: true,\n    pauseButton: true,\n    cancelButton: true,\n    disableDragAndDrop: false,\n    id: 'default-uploader-id'\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX3VwbG9hZF9jb21wb25lbnRzLy4vc3JjL2xpYi9jb21wb25lbnRzL1VwbG9hZC5yZWFjdC5qcz80ODIxIl0sIm5hbWVzIjpbIlVwbG9hZCIsInByb3BzIiwic3RhdGUiLCJwcm9ncmVzc0JhciIsIm1lc3NhZ2VTdGF0dXMiLCJmaWxlTGlzdCIsImZpbGVzIiwiaXNQYXVzZWQiLCJpc1VwbG9hZGluZyIsImlzSG92ZXJlZCIsImlzQ29tcGxldGUiLCJ0b2dnbGVIb3ZlcmVkIiwiYmluZCIsImNhbmNlbFVwbG9hZCIsInBhdXNlVXBsb2FkIiwic3RhcnRVcGxvYWQiLCJyZXN1bWFibGUiLCJSZXN1bWFibGVGaWVsZCIsIlJlc3VtYWJsZWpzIiwidGFyZ2V0Iiwic2VydmljZSIsInF1ZXJ5IiwiZmlsZVR5cGUiLCJmaWxldHlwZXMiLCJtYXhGaWxlcyIsIm1heEZpbGVTaXplIiwiZmlsZVR5cGVFcnJvckNhbGxiYWNrIiwic2V0U3RhdGUiLCJ0ZXN0TWV0aG9kIiwidGVzdENodW5rcyIsImhlYWRlcnMiLCJjaHVua1NpemUiLCJzaW11bHRhbmVvdXNVcGxvYWRzIiwiZm9yY2VDaHVua1NpemUiLCJhc3NpZ25Ccm93c2UiLCJ1cGxvYWRlciIsImRpc2FibGVEcmFnQW5kRHJvcCIsImFzc2lnbkRyb3AiLCJkcm9wWm9uZSIsIm9uIiwiZmlsZSIsImZpbGVBZGRlZE1lc3NhZ2UiLCJmaWxlTmFtZSIsIm9uRmlsZUFkZGVkIiwidXBsb2FkIiwiZmlsZVNlcnZlciIsImZpbGVOYW1lU2VydmVyIiwib2JqZWN0U2VydmVyIiwiSlNPTiIsInBhcnNlIiwiY3VycmVudEZpbGVzIiwicHVzaCIsImZpbGVOYW1lcyIsInNldFByb3BzIiwiY29tcGxldGVkTWVzc2FnZSIsIm9uRmlsZVN1Y2Nlc3MiLCJwcm9ncmVzcyIsInBhcnNlSW50Iiwic2V0VGltZW91dCIsImVycm9yQ291bnQiLCJvblVwbG9hZEVycm9yQ2FsbGJhY2siLCJjYW5jZWwiLCJwYXVzZSIsInRleHRMYWJlbCIsInN0YXJ0QnV0dG9uIiwiY2FuY2VsQnV0dG9uIiwicGF1c2VCdXR0b24iLCJnZXRTdHlsZSIsImNvbXBsZXRlU3R5bGUiLCJhY3RpdmVTdHlsZSIsImRlZmF1bHRTdHlsZSIsImdldENsYXNzIiwiZGlzYWJsZWRJbnB1dCIsImRpc2FibGVDbGFzcyIsImhvdmVyZWRDbGFzcyIsInVwbG9hZGluZ0NsYXNzIiwiY29tcGxldGVDbGFzcyIsImNsYXNzTmFtZSIsImlkIiwibm9kZSIsImZpbGVBY2NlcHQiLCJkaXNhYmxlSW5wdXQiLCJkaXNwbGF5Iiwid2lkdGgiLCJoZWlnaHQiLCJDb21wb25lbnQiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJudW1iZXIiLCJzdHJpbmciLCJkaXNhYmxlZENsYXNzIiwicGF1c2VkQ2xhc3MiLCJvYmplY3QiLCJhcnJheU9mIiwiYm9vbCIsImZ1bmMiLCJkZWZhdWx0UHJvcHMiLCJzaW11bHRhbmV1b3NVcGxvYWRzIiwidW5kZWZpbmVkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0lBRXFCQSxNOzs7QUFDakIsb0JBQVlDLEtBQVosRUFBbUI7QUFBQTs7QUFBQSxvSEFDVEEsS0FEUzs7QUFFZixjQUFLQyxLQUFMLEdBQWE7QUFDVEMseUJBQWEsQ0FESjtBQUVUQywyQkFBZSxFQUZOO0FBR1RDLHNCQUFVLEVBQUNDLE9BQU8sRUFBUixFQUhEO0FBSVRDLHNCQUFVLEtBSkQ7QUFLVEMseUJBQWEsS0FMSjtBQU1UQyx1QkFBVyxLQU5GO0FBT1RDLHdCQUFZO0FBUEgsU0FBYjtBQVNBLGNBQUtDLGFBQUwsR0FBcUIsTUFBS0EsYUFBTCxDQUFtQkMsSUFBbkIsT0FBckI7QUFDQSxjQUFLQyxZQUFMLEdBQW9CLE1BQUtBLFlBQUwsQ0FBa0JELElBQWxCLE9BQXBCO0FBQ0EsY0FBS0UsV0FBTCxHQUFtQixNQUFLQSxXQUFMLENBQWlCRixJQUFqQixPQUFuQjtBQUNBLGNBQUtHLFdBQUwsR0FB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U0FMUztBQU1sQnlELGVBQVcsbUJBTk87QUFPbEJILGtCQUFjLG1CQVBJO0FBUWxCRSxtQkFBZSxvQkFSRztBQVNsQmMsbUJBQWUsb0JBVEc7QUFVbEJDLGlCQUFhLGtCQVZLO0FBV2xCaEIsb0JBQWdCLHFCQVhFO0FBWWxCTCxrQkFBYyxFQVpJO0FBYWxCRCxpQkFBYSxFQWJLO0FBY2xCRCxtQkFBZSxFQWRHO0FBZWxCTCxlQUFXLDZCQWZPO0FBZ0JsQlQsc0JBQWtCLFlBaEJBO0FBaUJsQkYsZUFBVyxFQWpCTztBQWtCbEI3QixlQUFXMkUsU0FsQk87QUFtQmxCbEMsaUJBQWEsSUFuQks7QUFvQmxCRSxpQkFBYSxJQXBCSztBQXFCbEJELGtCQUFjLElBckJJO0FBc0JsQjdCLHdCQUFvQixLQXRCRjtBQXVCbEIwQyxRQUFJO0FBdkJjLENBQXRCIiwiZmlsZSI6Ii4vc3JjL2xpYi9jb21wb25lbnRzL1VwbG9hZC5yZWFjdC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwge0NvbXBvbmVudH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZXN1bWFibGVqcyBmcm9tICdyZXN1bWFibGVqcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVwbG9hZCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgcHJvZ3Jlc3NCYXI6IDAsXG4gICAgICAgICAgICBtZXNzYWdlU3RhdHVzOiAnJyxcbiAgICAgICAgICAgIGZpbGVMaXN0OiB7ZmlsZXM6IFtdfSxcbiAgICAgICAgICAgIGlzUGF1c2VkOiBmYWxzZSxcbiAgICAgICAgICAgIGlzVXBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGlzSG92ZXJlZDogZmFsc2UsXG4gICAgICAgICAgICBpc0NvbXBsZXRlOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRvZ2dsZUhvdmVyZWQgPSB0aGlzLnRvZ2dsZUhvdmVyZWQuYmluZCh0aGlzKVxuICAgICAgICB0aGlzLmNhbmNlbFVwbG9hZCA9IHRoaXMuY2FuY2VsVXBsb2FkLmJpbmQodGhpcylcbiAgICAgICAgdGhpcy5wYXVzZVVwbG9hZCA9IHRoaXMucGF1c2VVcGxvYWQuYmluZCh0aGlzKVxuICAgICAgICB0aGlzLnN0YXJ0VXBsb2FkID0gdGhpcy5zdGFydFVwbG9hZC5iaW5kKHRoaXMpXG4gICAgICAgIHRoaXMucmVzdW1hYmxlID0gbnVsbDtcbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcblxuICAgICAgICBjb25zdCBSZXN1bWFibGVGaWVsZCA9IG5ldyBSZXN1bWFibGVqcyh7XG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXMucHJvcHMuc2VydmljZSxcbiAgICAgICAgICAgIHF1ZXJ5OiB7fSxcbiAgICAgICAgICAgIGZpbGVUeXBlOiB0aGlzLnByb3BzLmZpbGV0eXBlcyxcbiAgICAgICAgICAgIG1heEZpbGVzOiB0aGlzLnByb3BzLm1heEZpbGVzLFxuICAgICAgICAgICAgbWF4RmlsZVNpemU6IHRoaXMucHJvcHMubWF4RmlsZVNpemUsXG4gICAgICAgICAgICBmaWxlVHlwZUVycm9yQ2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVN0YXR1czogJ0ludmFsaWQgZmlsZSB0eXBlISdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZXN0TWV0aG9kOiAncG9zdCcsXG4gICAgICAgICAgICB0ZXN0Q2h1bmtzOiBmYWxzZSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgY2h1bmtTaXplOiB0aGlzLnByb3BzLmNodW5rU2l6ZSxcbiAgICAgICAgICAgIHNpbXVsdGFuZW91c1VwbG9hZHM6IHRoaXMucHJvcHMuc2ltdWx0YW5lb3VzVXBsb2FkcyxcbiAgICAgICAgICAgIGZvcmNlQ2h1bmtTaXplOiBmYWxzZVxuICAgICAgICB9KTtcblxuICAgICAgICBSZXN1bWFibGVGaWVsZC5hc3NpZ25Ccm93c2UodGhpcy51cGxvYWRlcik7XG5cbiAgICAgICAgLy8gRW5hYmxlIG9yIERpc2FibGUgRHJhZ0FuZCBEcm9wXG4gICAgICAgIGlmICh0aGlzLnByb3BzLmRpc2FibGVEcmFnQW5kRHJvcCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIFJlc3VtYWJsZUZpZWxkLmFzc2lnbkRyb3AodGhpcy5kcm9wWm9uZSk7XG4gICAgICAgIH1cblxuICAgICAgICBSZXN1bWFibGVGaWVsZC5vbignZmlsZUFkZGVkJywgKGZpbGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VTdGF0dXM6IHRoaXMucHJvcHMuZmlsZUFkZGVkTWVzc2FnZSB8fCAnIFN0YXJ0aW5nIHVwbG9hZCEgb2YgJyArIGZpbGUuZmlsZU5hbWUsXG4gICAgICAgICAgICAgICAgaXNDb21wbGV0ZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnByb3BzLm9uRmlsZUFkZGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25GaWxlQWRkZWQoZmlsZSwgdGhpcy5yZXN1bWFibGUpO1xuICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgIFJlc3VtYWJsZUZpZWxkLnVwbG9hZCgpO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgUmVzdW1hYmxlRmllbGQub24oJ2ZpbGVTdWNjZXNzJywgKGZpbGUsIGZpbGVTZXJ2ZXIpID0+IHtcblxuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuZmlsZU5hbWVTZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgb2JqZWN0U2VydmVyID0gSlNPTi5wYXJzZShmaWxlU2VydmVyKTtcbiAgICAgICAgICAgICAgICBmaWxlLmZpbGVOYW1lID0gb2JqZWN0U2VydmVyW3RoaXMucHJvcHMuZmlsZU5hbWVTZXJ2ZXJdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWxlLmZpbGVOYW1lID0gZmlsZVNlcnZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjdXJyZW50RmlsZXMgPSB0aGlzLnN0YXRlLmZpbGVMaXN0LmZpbGVzO1xuICAgICAgICAgICAgY3VycmVudEZpbGVzLnB1c2goZmlsZSk7XG5cbiAgICAgICAgICAgIGxldCBmaWxlTmFtZXMgPSB0aGlzLnByb3BzLmZpbGVOYW1lc1xuICAgICAgICAgICAgZmlsZU5hbWVzLnB1c2goZmlsZS5maWxlTmFtZSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLnNldFByb3BzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5zZXRQcm9wcyh7XG4gICAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWVzOiBmaWxlTmFtZXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGZpbGVMaXN0OiB7ZmlsZXM6IGN1cnJlbnRGaWxlc30sXG4gICAgICAgICAgICAgICAgaXNDb21wbGV0ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlU3RhdHVzOiB0aGlzLnByb3BzLmNvbXBsZXRlZE1lc3NhZ2UgKyBmaWxlLmZpbGVOYW1lIHx8IGZpbGVTZXJ2ZXJcbiAgICAgICAgICAgIH0sICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJvcHMub25GaWxlU3VjY2VzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uRmlsZVN1Y2Nlc3MoZmlsZSwgZmlsZVNlcnZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIFJlc3VtYWJsZUZpZWxkLm9uKCdwcm9ncmVzcycsICgpID0+IHtcblxuXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBpc1VwbG9hZGluZzogUmVzdW1hYmxlRmllbGQuaXNVcGxvYWRpbmcoKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICgoUmVzdW1hYmxlRmllbGQucHJvZ3Jlc3MoKSAqIDEwMCkgPCAxMDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVN0YXR1czogcGFyc2VJbnQoUmVzdW1hYmxlRmllbGQucHJvZ3Jlc3MoKSAqIDEwMCwgMTApICsgJyUnLFxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0JhcjogUmVzdW1hYmxlRmllbGQucHJvZ3Jlc3MoKSAqIDEwMFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0JhcjogMFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIFJlc3VtYWJsZUZpZWxkLm9uKCdmaWxlRXJyb3InLCAoZmlsZSwgZXJyb3JDb3VudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vblVwbG9hZEVycm9yQ2FsbGJhY2soZmlsZSwgZXJyb3JDb3VudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMucmVzdW1hYmxlID0gUmVzdW1hYmxlRmllbGQ7XG4gICAgfVxuXG4gICAgY2FuY2VsVXBsb2FkKCkge1xuICAgICAgICB0aGlzLnJlc3VtYWJsZS5jYW5jZWwoKTtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGZpbGVMaXN0OiB7ZmlsZXM6IFtdfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwYXVzZVVwbG9hZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmlzUGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VtYWJsZS5wYXVzZSgpO1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgaXNQYXVzZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgaXNVcGxvYWRpbmc6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZXN1bWFibGUudXBsb2FkKCk7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBpc1BhdXNlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNVcGxvYWRpbmc6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhcnRVcGxvYWQoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgaXNQYXVzZWQ6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHRvZ2dsZUhvdmVyZWQoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgaXNIb3ZlcmVkOiAhdGhpcy5zdGF0ZS5pc0hvdmVyZWRcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG5cbiAgICAgICAgbGV0IGZpbGVMaXN0ID0gbnVsbDtcblxuICAgICAgICBsZXQgdGV4dExhYmVsID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMudGV4dExhYmVsKSB7XG4gICAgICAgICAgICB0ZXh0TGFiZWwgPSB0aGlzLnByb3BzLnRleHRMYWJlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzdGFydEJ1dHRvbiA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnN0YXJ0QnV0dG9uKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJvcHMuc3RhcnRCdXR0b24gPT09J3N0cmluZycgfHwgdHlwZW9mIHRoaXMucHJvcHMuc3RhcnRCdXR0b24gPT09J2Jvb2xlYW4nICkgc3RhcnRCdXR0b24gPSA8bGFiZWw+XG4gICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e3RoaXMuc3RhdGUuaXNVcGxvYWRpbmd9XG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJyZXN1bWFibGUtYnRuLXN0YXJ0XCJcbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuc3RhcnRVcGxvYWR9Pnt0aGlzLnByb3BzLnN0YXJ0QnV0dG9uICYmICd1cGxvYWQnfVxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPC9sYWJlbD47XG4gICAgICAgICAgICBlbHNlIHN0YXJ0QnV0dG9uID10aGlzLnByb3BzLnN0YXJ0QnV0dG9uXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY2FuY2VsQnV0dG9uID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuY2FuY2VsQnV0dG9uKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJvcHMuY2FuY2VsQnV0dG9uID09PSAgJ3N0cmluZycgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgdGhpcy5wcm9wcy5jYW5jZWxCdXR0b24gPT09ICAnYm9vbGVhbicpIGNhbmNlbEJ1dHRvbiA9IDxsYWJlbD5cbiAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICBkaXNhYmxlZD17IXRoaXMuc3RhdGUuaXNVcGxvYWRpbmd9XG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJyZXN1bWFibGUtYnRuLWNhbmNlbFwiXG4gICAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLmNhbmNlbFVwbG9hZH0+e3RoaXMucHJvcHMuY2FuY2VsQnV0dG9uICYmICdjYW5jZWwnfVxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPC9sYWJlbD47XG4gICAgICAgICAgICBlbHNlIGNhbmNlbEJ1dHRvbiA9IHRoaXMucHJvcHMuY2FuY2VsQnV0dG9uXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcGF1c2VCdXR0b24gPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5wYXVzZUJ1dHRvbikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnByb3BzLnBhdXNlQnV0dG9uID09PSAgJ3N0cmluZydcbiAgICAgICAgICAgICAgICB8fCB0eXBlb2YgdGhpcy5wcm9wcy5wYXVzZUJ1dHRvbiA9PT0gICdib29sZWFuJykgcGF1c2VCdXR0b24gPSA8bGFiZWw+XG4gICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9eyF0aGlzLnN0YXRlLmlzVXBsb2FkaW5nfVxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicmVzdW1hYmxlLWJ0bi1wYXVzZVwiXG4gICAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLnBhdXNlVXBsb2FkfT5cbiAgICAgICAgICAgICAgICAgIHt0aGlzLnByb3BzLnBhdXNlQnV0dG9uXG4gICAgICAgICAgICAgICAgICAgJiYgKHRoaXMuc3RhdGUuaXNQYXVzZWQgPyAncmVzdW1lJyA6ICdwYXVzZScpfVxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPC9sYWJlbD47XG4gICAgICAgICAgICBlbHNlIHBhdXNlQnV0dG9uID0gdGhpcy5wcm9wcy5wYXVzZUJ1dHRvblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGdldFN0eWxlID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuaXNDb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNvbXBsZXRlU3R5bGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUuaXNIb3ZlcmVkIHx8IHRoaXMuc3RhdGUuaXNVcGxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5hY3RpdmVTdHlsZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuZGVmYXVsdFN0eWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGdldENsYXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuZGlzYWJsZWRJbnB1dCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5kaXNhYmxlQ2xhc3M7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUuaXNIb3ZlcmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLmhvdmVyZWRDbGFzcztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5pc1VwbG9hZGluZykge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy51cGxvYWRpbmdDbGFzcztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5pc0NvbXBsZXRlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNvbXBsZXRlQ2xhc3M7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUuaXNQYXVzZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY29tcGxldGVDbGFzcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNsYXNzTmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgaWQ9e3RoaXMucHJvcHMuaWR9IGNsYXNzTmFtZT17Z2V0Q2xhc3MoKX0gcmVmPXtub2RlID0+IHRoaXMuZHJvcFpvbmUgPSBub2RlfSA+XG4gICAgICAgICAgICAgICAgPGxhYmVsXG4gICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXtnZXRTdHlsZSgpfVxuICAgICAgICAgICAgICAgICAgICAgICBvbk1vdXNlRW50ZXI9e3RoaXMudG9nZ2xlSG92ZXJlZH1cbiAgICAgICAgICAgICAgICAgICAgICAgb25Nb3VzZUxlYXZlPXt0aGlzLnRvZ2dsZUhvdmVyZWR9XG4gICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICB7dGhpcy5zdGF0ZS5tZXNzYWdlU3RhdHVzID09ICcnID8gdGV4dExhYmVsIDogdGhpcy5zdGF0ZS5tZXNzYWdlU3RhdHVzfVxuICAgICAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZj17bm9kZT0+IHRoaXMudXBsb2FkZXIgPSBub2RlfVxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cImZpbGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPSdidG4nXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lPXt0aGlzLnByb3BzLmlkICsgJy11cGxvYWQnfVxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXB0PXt0aGlzLnByb3BzLmZpbGVBY2NlcHQgfHwgJyonfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e3RoaXMucHJvcHMuZGlzYWJsZUlucHV0IHx8IGZhbHNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3snb3BhY2l0eSc6ICcwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3dpZHRoJzogJzAuMXB4JScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdoZWlnaHQnOiAnMC4xcHglJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3Bvc2l0aW9uJzogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ292ZXJmbG93JzogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd6LWluZGV4JzogJy0xJ319XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInByb2dyZXNzXCJcbiAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IHRoaXMuc3RhdGUucHJvZ3Jlc3NCYXIgPT09IDAgPyAnbm9uZScgOiAnYmxvY2snXG4gICAgICAgICAgICAgICAgICAgICB9fT5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwcm9ncmVzcy1iYXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5zdGF0ZS5wcm9ncmVzc0JhciArICclJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogJzEwMCUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgfX0+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIHtmaWxlTGlzdH1cbiAgICAgICAgICAgICAgICB7c3RhcnRCdXR0b259XG4gICAgICAgICAgICAgICAge3BhdXNlQnV0dG9ufVxuICAgICAgICAgICAgICAgIHtjYW5jZWxCdXR0b259XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cblVwbG9hZC5wcm9wVHlwZXMgPSB7XG4gICAgLyoqXG4gICAgICogTWF4aW11bSBudW1iZXIgb2YgZmlsZXMgdGhhdCBjYW4gYmUgdXBsb2FkZWQgaW4gb25lIHNlc3Npb25cbiAgICAgKi9cbiAgICBtYXhGaWxlczogUHJvcFR5cGVzLm51bWJlcixcblxuICAgIC8qKlxuICAgICAqIE1heGltdW0gc2l6ZSBwZXIgZmlsZSBpbiBieXRlcy5cbiAgICAgKi9cbiAgICBtYXhGaWxlU2l6ZTogUHJvcFR5cGVzLm51bWJlcixcblxuICAgIC8qKlxuICAgICAqIFNpemUgb2YgZmlsZSBjaHVua3MgdG8gc2VuZCB0byBzZXJ2ZXIuXG4gICAgICovXG4gICAgY2h1bmtTaXplOiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIHNpbXVsdGFuZW91cyB1cGxvYWRzIHRvIHNlbGVjdFxuICAgICAqL1xuICAgIHNpbXVsdGFuZW91c1VwbG9hZHM6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VydmljZSB0byBzZW5kIHRoZSBmaWxlcyB0b1xuICAgICAqL1xuICAgIHNlcnZpY2U6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgICAvKipcbiAgICAgKiBDbGFzcyB0byBhZGQgdG8gdGhlIHVwbG9hZCBjb21wb25lbnQgYnkgZGVmYXVsdFxuICAgICAqL1xuICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAgIC8qKlxuICAgICAqIENsYXNzIHRvIGFkZCB0byB0aGUgdXBsb2FkIGNvbXBvbmVudCB3aGVuIGl0IGlzIGhvdmVyZWRcbiAgICAgKi9cbiAgICBob3ZlcmVkQ2xhc3M6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgICAvKipcbiAgICAgKiBDbGFzcyB0byBhZGQgdG8gdGhlIHVwbG9hZCBjb21wb25lbnQgd2hlbiBpdCBpcyBkaXNhYmxlZFxuICAgICAqL1xuICAgIGRpc2FibGVkQ2xhc3M6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgICAvKipcbiAgICAgKiBDbGFzcyB0byBhZGQgdG8gdGhlIHVwbG9hZCBjb21wb25lbnQgd2hlbiBpdCBpcyBwYXVzZWRcbiAgICAgKi9cbiAgICBwYXVzZWRDbGFzczogUHJvcFR5cGVzLnN0cmluZyxcblxuICAgIC8qKlxuICAgICAqIENsYXNzIHRvIGFkZCB0byB0aGUgdXBsb2FkIGNvbXBvbmVudCB3aGVuIGl0IGlzIGNvbXBsZXRlXG4gICAgICovXG4gICAgY29tcGxldGVDbGFzczogUHJvcFR5cGVzLnN0cmluZyxcblxuICAgIC8qKlxuICAgICAqIENsYXNzIHRvIGFkZCB0byB0aGUgdXBsb2FkIGNvbXBvbmVudCB3aGVuIGl0IGlzIHVwbG9hZGluZ1xuICAgICAqL1xuICAgIHVwbG9hZGluZ0NsYXNzOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gICAgLyoqXG4gICAgICogU3R5bGUgYXR0cmlidXRlcyB0byBhZGQgdG8gdGhlIHVwbG9hZCBjb21wb25lbnRcbiAgICAgKi9cbiAgICBkZWZhdWx0U3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgICAvKipcbiAgICAgKiBTdHlsZSB3aGVuIHVwbG9hZCBjb21wb25lbnQgaXMgaG92ZXJlZCBvdmVyXG4gICAgICovXG4gICAgYWN0aXZlU3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgIC8qKlxuICAgICogU3R5bGUgd2hlbiB1cGxvYWQgaXMgY29tcGxldGVkICh1cGxvYWQgZmluaXNoZWQpXG4gICAgKi9cbiAgICBjb21wbGV0ZVN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHN0cmluZyB0byBkaXNwbGF5IGluIHRoZSB1cGxvYWQgY29tcG9uZW50XG4gICAgICovXG4gICAgdGV4dExhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gICAgLyoqXG4gICAgICogTWVzc2FnZSB0byBkaXNwbGF5IHdoZW4gdXBsb2FkIGNvbXBsZXRlZFxuICAgICAqL1xuICAgIGNvbXBsZXRlZE1lc3NhZ2U6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZXMgb2YgdGhlIGZpbGVzIHVwbG9hZGVkXG4gICAgICovXG4gICAgZmlsZU5hbWVzOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc3RyaW5nKSxcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgYWxsb3dlZCBmaWxlIHR5cGVzLCBlLmcuIFsnanBnJywgJ3BuZyddXG4gICAgICovXG4gICAgZmlsZXR5cGVzOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc3RyaW5nKSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgb3Igbm90IHRvIGhhdmUgYSBzdGFydCBidXR0b25cbiAgICAgKi9cbiAgICBzdGFydEJ1dHRvbjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCB0byBoYXZlIGEgcGF1c2UgYnV0dG9uXG4gICAgICovXG4gICAgcGF1c2VCdXR0b246IFByb3BUeXBlcy5ib29sLFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBvciBub3QgdG8gaGF2ZSBhIGNhbmNlbCBidXR0b25cbiAgICAgKi9cbiAgICBjYW5jZWxCdXR0b246IFByb3BUeXBlcy5ib29sLFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBvciBub3QgdG8gYWxsb3cgZmlsZSBkcmFnIGFuZCBkcm9wXG4gICAgICovXG4gICAgZGlzYWJsZURyYWdBbmREcm9wOiBQcm9wVHlwZXMuYm9vbCxcblxuICAgIC8qKlxuICAgICAqIERhc2gtc3VwcGxpZWQgZnVuY3Rpb24gZm9yIHVwZGF0aW5nIHByb3BzXG4gICAgICovXG4gICAgc2V0UHJvcHM6IFByb3BUeXBlcy5mdW5jLFxuXG4gICAgLyoqXG4gICAgICogVXNlciBzdXBwbGllZCBpZCBvZiB0aGlzIGNvbXBvbmVudFxuICAgICAqL1xuICAgIGlkOiBQcm9wVHlwZXMuc3RyaW5nXG5cbn1cblxuVXBsb2FkLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBtYXhGaWxlczogMSxcbiAgICBtYXhGaWxlU2l6ZTogMTAyNCAqIDEwMjQgKiAxMCxcbiAgICBjaHVua1NpemU6IDEwMjQgKiAxMDI0LFxuICAgIHNpbXVsdGFuZXVvc1VwbG9hZHM6IDEsXG4gICAgc2VydmljZTogJy91cGxvYWQnLFxuICAgIGNsYXNzTmFtZTogJ3Jlc3VtYWJsZS1kZWZhdWx0JyxcbiAgICBob3ZlcmVkQ2xhc3M6ICdyZXN1bWFibGUtaG92ZXJlZCcsXG4gICAgY29tcGxldGVDbGFzczogJ3Jlc3VtYWJsZS1jb21wbGV0ZScsXG4gICAgZGlzYWJsZWRDbGFzczogJ3Jlc3VtYWJsZS1kaXNhYmxlZCcsXG4gICAgcGF1c2VkQ2xhc3M6ICdyZXN1bWFibGUtcGF1c2VkJyxcbiAgICB1cGxvYWRpbmdDbGFzczogJ3Jlc3VtYWJsZS11cGxvYWRpbmcnLFxuICAgIGRlZmF1bHRTdHlsZToge30sXG4gICAgYWN0aXZlU3R5bGU6IHt9LFxuICAgIGNvbXBsZXRlU3R5bGU6IHt9LFxuICAgIHRleHRMYWJlbDogJ0NsaWNrIEhlcmUgdG8gU2VsZWN0IGEgRmlsZScsXG4gICAgY29tcGxldGVkTWVzc2FnZTogJ0NvbXBsZXRlISAnLFxuICAgIGZpbGVOYW1lczogW10sXG4gICAgZmlsZXR5cGVzOiB1bmRlZmluZWQsXG4gICAgc3RhcnRCdXR0b246IHRydWUsXG4gICAgcGF1c2VCdXR0b246IHRydWUsXG4gICAgY2FuY2VsQnV0dG9uOiB0cnVlLFxuICAgIGRpc2FibGVEcmFnQW5kRHJvcDogZmFsc2UsXG4gICAgaWQ6ICdkZWZhdWx0LXVwbG9hZGVyLWlkJ1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/lib/components/Upload.react.js\n");

/***/ }),

/***/ "./src/lib/index.js":
/*!**************************!*\
  !*** ./src/lib/index.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Upload = undefined;\n\nvar _Upload = __webpack_require__(/*! ./components/Upload.react */ \"./src/lib/components/Upload.react.js\");\n\nvar _Upload2 = _interopRequireDefault(_Upload);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.Upload = _Upload2.default; /* eslint-disable import/prefer-default-export *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX3VwbG9hZF9jb21wb25lbnRzLy4vc3JjL2xpYi9pbmRleC5qcz9kNzVhIl0sIm5hbWVzIjpbIlVwbG9hZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUNBOzs7Ozs7UUFHSUEsTSxHQUFBQSxnQixFQUpKIiwiZmlsZSI6Ii4vc3JjL2xpYi9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9wcmVmZXItZGVmYXVsdC1leHBvcnQgKi9cbmltcG9ydCBVcGxvYWQgZnJvbSAnLi9jb21wb25lbnRzL1VwbG9hZC5yZWFjdCc7XG5cbmV4cG9ydCB7XG4gICAgVXBsb2FkXG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/lib/index.js\n");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "React" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("(function() { module.exports = window[\"React\"]; }());//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX3VwbG9hZF9jb21wb25lbnRzL2V4dGVybmFsIFwiUmVhY3RcIj9jNDgxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGFBQWEsa0NBQWtDLEVBQUUiLCJmaWxlIjoicmVhY3QuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKSB7IG1vZHVsZS5leHBvcnRzID0gd2luZG93W1wiUmVhY3RcIl07IH0oKSk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///react\n");

/***/ })

/******/ });